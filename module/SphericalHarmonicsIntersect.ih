// Copyright 2009-2021 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "rkcommon/math/vec.ih"
#include "math/AffineSpace.ih"

const uniform float EPSILON = 1e-3;
const int STEPS_ = 70;

struct SHIntersections
{
  unsigned int numIntersections;
  float roots[10];
  vec3f normals[10];
};
float sign(float v)
{
  return v < 0.f ? -1.f : 1.f;
}

#define k01 0.2820947918 // sqrt(  1/PI)/2
#define k02 0.4886025119 // sqrt(  3/PI)/2
#define k03 1.0925484306 // sqrt( 15/PI)/2
#define k04 0.3153915652 // sqrt(  5/PI)/4
#define k05 0.5462742153 // sqrt( 15/PI)/4
#define k06 0.5900435860 // sqrt( 70/PI)/8
#define k07 2.8906114210 // sqrt(105/PI)/2
#define k08 0.4570214810 // sqrt( 42/PI)/8
#define k09 0.3731763300 // sqrt(  7/PI)/4
#define k10 1.4453057110 // sqrt(105/PI)/4
#define k11 2.5033429418 // sqrt(35/PI)*3/4
#define k12 1.7701307698 // sqrt(70/PI)*3/8
#define k13 0.9461746958 // sqrt(5/PI)*3/4
#define k14 0.6690465436 // sqrt(10/PI)*3/8
#define k15 0.1057855469 // sqrt(1/PI)*3/16
#define k16 0.4730873479 // sqrt(5/PI)*3/8
#define k17 0.6258357355 // sqrt(35/PI)*3/16

#define sqrt2 sqrt(2.f);
#define four_pi_inv sqrt(four_pi);

float genSH(int l, int m, vec3f) {
  float condonShortley = (m % 2) ? -1.f : 1.f;
  float val = condonShortley * sqrt2;
  float inner = (2.f * l +1.f) * four_pi_inv;
}

#define INV_PI 1.0f/PI;

float shFunctions(vec3f n, uniform float* c) {

  const float r = length(n);
  n = n/r; // normalize
  /* n = make_vec3f(n.z, n.x, n.y); */

  const float x =n.x;
  const float y = n.y;
  const float z = n.z;
  const float x2 = x*x;
  const float y2 = y*y;
  const float z2 = z*z;
  const float xy = x*y;
  const float yz = y*z;
  const float xz = x*z;
  const float v5z2 = 5.f*z2;
  const float v7z2 = 7.f*z2;
  const float v3x2 = 3.f*x2;
  const float v3y2 = 3.f*y2;
  const float v7z2min1 = v7z2-1.f;
  const float v7z2min3 = v7z2-3.f;
  const float v5z2min1 = v5z2-1.f;
  const float x2miny2 = x2-y2;
  const float x2min3y2 = x2-v3y2;

  #if 1 // hyper optimize
  float v =
   (c[0]*k01) // l=0, m=0
  //----------------------------------------------------------
	-k02*(c[1]*y-c[2]*z+c[3]*x)
  //----------------------------------------------------------
  +k03*(c[4]*xy-c[5]*yz-c[7]*xz+c[8]*0.5f*x2miny2)
  +c[6]*(k04*(3.f*z2-1.f)) // l=2, m= 0
  //----------------------------------------------------------
  -k06*(c[9]*y*(v3x2-y2)+c[16]*x*(x2-v3y2))
  +k07*z*(c[10]*xy+c[14]*0.5f*(x2miny2))
  -k08*v5z2min1*(c[11]*y+c[13]*x)
  +c[12]*(k09*z*(v5z2-3.f)) // l=3, m= 0
  //----------------------------------------------------------
  /* +k11*(c[16]*xy*x2miny2-0.5*(c[17]*yz*(v3x2-y2)+c[23]*xz*x2min3y2)+0.25f*c[24]*(x2*x2min3y2-y2*(v3x2-y2))); */
  /* +k14*(-c[19]*y*v7z2min3-c[21]*x*v7z2min3) */
  +c[16]*(k11*xy*(x2miny2)) // l=4, m=-4
  -c[17]*(k12*yz*(v3x2-y2)) // l=4, m=-3
  +c[18]*(k13*xy*(v7z2min1)) // l=4, m=-2
  -c[19]*(k14*y*(v7z2min3)) // l=4, m=-1
  +c[20]*(k15*(35.f*z2*z2-30.f*z2+3.f)) // l=4, m= 0
  -c[21]*(k14*x*(v7z2min3)) // l=4, m= 1
  +c[22]*(k16*(x2miny2)*(v7z2min1)) // l=4, m= 2
  -c[23]*(k12*xz*(x2min3y2)) // l=4, m= 3
  +c[24]*(k17*x2*(x2min3y2)-y2*(v3x2-y2)); // l=4, m= 4
  return r-abs(v);
#else //legible
  const uniform float invPi4 = 0.25 / PI;
  return
   (
   (c[0]*k01) // l=0, m=0
   )*(invPi4)+
  //----------------------------------------------------------
	/* -c[1]*(k02*y) // l=1, m=-1 */
  /* +c[2]*(k02*z) // l=1, m= 0 */
  /* -c[3]*(k02*x) // l=1, m= 1 */
  //----------------------------------------------------------
  (
	+c[1]*(k03*xy) // l=2, m=-2
  -c[2]*(k03*yz) // l=2, m=-1
  +c[3]*(k04*(3.f*z2-1.f)) // l=2, m= 0
  -c[4]*(k03*xz) // l=2, m= 1
  +c[5]*(k05*(x2miny2)) // l=2, m= 2
   )*(5.f*invPi4)+
  //----------------------------------------------------------
  /* -c[9]*(k06*y*(v3x2-y2)) // l=3, m=-3 */
  /* +c[10]*(k07*xy*z) // l=3, m=-2 */
  /* -c[11]*(k08*y*(v5z2min1)) // l=3, m=-1 */
  /* +c[12]*(k09*z*(v5z2-3.f)) // l=3, m= 0 */
  /* -c[13]*(k08*x*(v5z2min1)) // l=3, m= 1 */
  /* +c[14]*(k10*z*(x2miny2)) // l=3, m= 2 */
  /* -c[15]*(k06*x*(x2-v3y2)) // l=3, m= 3 */
  //----------------------------------------------------------
  (
  +c[6]*(k11*xy*(x2miny2)) // l=4, m=-4
  -c[7]*(k12*yz*(v3x2-y2)) // l=4, m=-3
  +c[8]*(k13*xy*(v7z2min1)) // l=4, m=-2
  -c[9]*(k14*y*(v7z2min3)) // l=4, m=-1
  +c[10]*(k15*(35.f*z2*z2-30.f*z2+3.f)) // l=4, m= 0
  -c[11]*(k14*x*(v7z2min3)) // l=4, m= 1
  +c[12]*(k16*(x2miny2)*(v7z2min1)) // l=4, m= 2
  -c[13]*(k12*xz*(x2min3y2)) // l=4, m= 3
  +c[14]*(k17*x2*(x2min3y2)-y2*(v3x2-y2)) // l=4, m= 4
  )*(9.f*invPi4);
  #endif

}

float SH(int l, int m, vec3f n) {
  if( l==0 )          return  k01;
  //----------------------------------------------------------
	if (l==1 && m==-1) return -k02*n.y;
  if (l==1 && m== 0) return  k02*n.z;
  if (l==1 && m== 1) return -k02*n.x;
  //----------------------------------------------------------
	if (l==2 && m==-2) return  k03*n.x*n.y;
  if (l==2 && m==-1) return -k03*n.y*n.z;
  if (l==2 && m== 0) return  k04*(3.f*n.z*n.z-1.f);
  if (l==2 && m== 1) return -k03*n.x*n.z;
  if (l==2 && m== 2) return  k05*(n.x*n.x-n.y*n.y);
  //----------------------------------------------------------
  if (l==3 && m==-3) return -k06*n.y*(3.f*n.x*n.x-n.y*n.y);
  if (l==3 && m==-2) return  k07*n.z*n.y*n.x;
  if (l==3 && m==-1) return -k08*n.y*(5.f*n.z*n.z-1.f);
  if (l==3 && m== 0) return  k09*n.z*(5.f*n.z*n.z-3.f);
  if (l==3 && m== 1) return -k08*n.x*(5.f*n.z*n.z-1.f);
  if (l==3 && m== 2) return  k10*n.z*(n.x*n.x-n.y*n.y);
  if (l==3 && m== 3) return -k06*n.x*(n.x*n.x-3.f*n.y*n.y);
  //----------------------------------------------------------
  if (l==4 && m==-4) return  k11*n.x*n.y*(n.x*n.x-n.y*n.y);
  if (l==4 && m==-3) return -k12*n.y*n.z*(3.f*n.x*n.x-n.y*n.y);
  if (l==4 && m==-2) return  k13*n.x*n.y*(7.f*n.z*n.z-1.f);
  if (l==4 && m==-1) return -k14*n.y*n.z*(7.f*n.z*n.z-3.f);
  if (l==4 && m== 0) return  k15*(35.f*n.z*n.z*n.z*n.z-30.f*n.z*n.z+3.f);
  if (l==4 && m== 1) return -k14*n.x*n.z*(7.f*n.z*n.z-3.f);
  if (l==4 && m== 2) return  k16*(n.x*n.x-n.y*n.y)*(7.f*n.z*n.z-1.f);
  if (l==4 && m== 3) return -k12*n.x*n.z*(n.x*n.x-3.f*n.y*n.y);
  if (l==4 && m== 4) return  k17*n.x*n.x*(n.x*n.x-3.f*n.y*n.y)-n.y*n.y*(3.f*n.x*n.x-n.y*n.y);
  //----------------------------------------------------------
  return 0.0;
}

vec3f get_sh_glyph_normal(uniform float* sh_coeffs, varying vec3f point){
    /* Computes a unit normal vector for a spherical harmonics glyph. */
    /* :param sh_coeffs: Spherical harmonics coefficients for bands 0, 2 and 4. See */
    /*     evaluate_sh_4() for their order. Array of shape (15, ...). */
    /* :param point: The position on the glyph at which the normal should be */
    /*     evaluated, relative to the glyph center. Shape (3, ...). */
    /* :return: The normalized normal vector. Shape (3, ...). */
    /* sh, gradient = evaluate_sh_4(offset, True); */

    float z_2 = point.z * point.z;
    float r_2 = point.x * point.x + point.y * point.y;
    // Evaluate the relevant associated Legendre polynomials. At such low degree,
    // the recurrent scheme is not worthwhile. We skip odd bands and constant or
    // linear polynomials.
    float legendre_4_0 = z_2 * (z_2 - 3.0*r_2) + 3.0/8.0 * r_2 * r_2;
    float scaled_legendre_4_1 = 2.67618617422915667 * point.z * (-z_2 + 0.75 * r_2);
    float scaled_legendre_4_2 = 2.83852408727268005 * (z_2 - (1.0 / 6.0) * r_2);
      // Evaluate the Fourier basis. Again, we omit constant and linear terms.
    float cosine_2 = r_2 - 2.0 * point.y * point.y;
    float sine_2 = 2.0 * point.x * point.y;
    float cosine_3 = point.x * cosine_2 - point.y * sine_2;
    float sine_3 = point.x * sine_2 + point.y * cosine_2;
    float cosine_4 = point.x * cosine_3 - point.y * sine_3;
    float sine_4 = point.x * sine_3 + point.y * cosine_3;
      // Assemble the Legendre polynomials and the Fourier basis with appropriate
      // constant factors and homogenize to degree 4 by multiplying one_2 as needed
    float one_2 = r_2 + z_2;
    float sh[] = {0.282094791773878143 * one_2 * one_2,
                  0.546274215296039535 * one_2 * sine_2,
                  -1.09254843059207907 * one_2 * point.y * point.z,
                  0.630783130505040012 * one_2 * (z_2 - 0.5 * r_2),
                  -1.09254843059207907 * one_2 * point.x * point.z,
                  0.546274215296039535 * one_2 * cosine_2,
                  0.625835735449176135 * sine_4,
                  -1.77013076977993053 * sine_3 * point.z,
                  sine_2 * scaled_legendre_4_2,
                  point.y * scaled_legendre_4_1,
                   0.846284375321634430 * legendre_4_0,
                   point.x * scaled_legendre_4_1,
                   cosine_2 * scaled_legendre_4_2,
                   -1.77013076977993053 * cosine_3 * point.z,
                   0.625835735449176135 * cosine_4};

    float poly_value = 0;
    for (uniform int i = 0; i < 15; ++i)
      poly_value += sh[i] * sh_coeffs[i];

    // Prepare a few common subexpressions. Many of them are linear in
    // x^2, y^2, z^2 and named by the corresponding factors. a, b, c are
    // various literals, m is -1.
    float xa3_ya1_za1 = 1.09254843059207907 * (one_2 + 2.0 * point.x * point.x);
    float xa1_ya3_za1 = 1.09254843059207907 * (one_2 + 2.0 * point.y * point.y);
    float xa1_ya1_za3 = 1.09254843059207907 * (one_2 + 2.0 * z_2);
    float xb1_yb1_zb1 = 1.128379167095512574 * one_2;
    float xc2_yc2_zcm1 = -1.26156626101008002 * (r_2 - 0.5 * z_2);
    float x1_y1_zm4 = r_2 - 4.0 * z_2;
    float xyz = point.x * point.y * point.z;
    float cosine_2_z = cosine_2 * point.z;
    // Assemble the pieces to get the gradients. This is mostly just using
    // the product rule but there is a lot of manual optimization on top of
    // that. The gradient should be homogeneous of degree 3.
    float gradient[3][15];
    gradient[0][0] = xb1_yb1_zb1 * point.x;
    gradient[1][0] = xb1_yb1_zb1 * point.y;
    gradient[2][0] = xb1_yb1_zb1 * point.z;

    gradient[0][1] = point.y * xa3_ya1_za1;
    gradient[1][1] = point.x * xa1_ya3_za1;
    gradient[2][1] = 2.18509686118415814 * xyz;

    gradient[0][2] = -gradient[2][1];
    gradient[1][2] = -point.z * xa1_ya3_za1;
    gradient[2][2] = -point.y * xa1_ya1_za3;

    gradient[0][3] = point.x * xc2_yc2_zcm1;
    gradient[1][3] = point.y * xc2_yc2_zcm1;
    gradient[2][3] = 0.630783130505040012 * point.z * (r_2 + 4.0 * z_2);

    gradient[0][4] = -point.z * xa3_ya1_za1;
    gradient[1][4] = -gradient[2][1];
    gradient[2][4] = -point.x * xa1_ya1_za3;

    gradient[0][5] = 1.09254843059207907 * point.x * (cosine_2 + one_2);
    gradient[1][5] = 1.09254843059207907 * point.y * (cosine_2 - one_2);
    gradient[2][5] = 1.09254843059207907 * point.z * cosine_2;

    gradient[0][6] = 2.50334294179670454 * sine_3;
    gradient[1][6] = 2.50334294179670454 * cosine_3;
    gradient[2][6] = 0.0;

    gradient[0][7] = -10.6207846186795827 * xyz;
    gradient[1][7] = -5.31039230933979159 * cosine_2_z;
    gradient[2][7] = -1.77013076977993053 * sine_3;

    gradient[0][8] = 0.8660254037844386468 * point.y * (-xa3_ya1_za1 + 7.64783901414455349 * z_2);
    gradient[1][8] = 0.8660254037844386468 * point.x * (-xa1_ya3_za1 + 7.64783901414455349 * z_2);
    gradient[2][8] = 11.35409634909072096 * xyz;

    gradient[0][9] = 4.014279261343735008 * xyz;
    gradient[1][9] = 1.837117307087383575 * point.z * (xa1_ya3_za1 - 2.549279671381517831 * z_2);
    gradient[2][9] = 2.007139630671867504 * x1_y1_zm4 * point.y;

    gradient[0][10] = 1.269426562982451646 * x1_y1_zm4 * point.x;
    gradient[1][10] = 1.269426562982451646 * x1_y1_zm4 * point.y;
    gradient[2][10] = -5.077706251929806583 * point.z * (r_2 - (2.0 / 3.0) * z_2);

    gradient[0][11] = 1.837117307087383575 * point.z * (xa3_ya1_za1 - 2.549279671381517831 * z_2);
    gradient[1][11] = gradient[0][9];
    gradient[2][11] = 2.007139630671867504 * x1_y1_zm4 * point.x;

    gradient[0][12] = 5.677048174545360109 * point.x * (z_2 - (1.0 / 3.0) * point.x*point.x);
    gradient[1][12] = -5.677048174545360109 * point.y * (z_2 - (1.0 / 3.0) * point.y*point.y);
    gradient[2][12] = 5.677048174545360109 * cosine_2_z;

    gradient[0][13] = gradient[1][7];
    gradient[1][13] = -gradient[0][7];
    gradient[2][13] = -1.77013076977993053 * cosine_3;

    gradient[0][14] = gradient[1][6];
    gradient[1][14] = -gradient[0][6];
    gradient[2][14] = 0.0;

    vec3f poly_gradient = make_vec3f(0,0,0);
    for (int j = 0; j < 15; ++j) {
      poly_gradient.x += gradient[0][j] * sh_coeffs[j];
      poly_gradient.y += gradient[1][j] * sh_coeffs[j];
      poly_gradient.z += gradient[2][j] * sh_coeffs[j];
    }
    float length_2 = point.x*point.x + point.y*point.y + point.z*point.z;
    vec3f normal = length_2 * poly_gradient - 5.0 * poly_value * point;
    return normalize(normal);
}

vec3f SHGradient(varying vec3f p,
                 uniform float* coeffs)
{
  const float eps = 0.001;

  const vec3f epsX = make_vec3f(eps,0.f,0.f);
  const vec3f epsY = make_vec3f(0.f,eps,0.f);
  const vec3f epsZ = make_vec3f(0.f,0.f,eps);

  const float plusX = shFunctions(p + epsX, coeffs);
  const float minX = shFunctions(p - epsX, coeffs);
  const float plusY = shFunctions(p + epsY, coeffs);
  const float minY = shFunctions(p - epsY, coeffs);
  const float plusZ = shFunctions(p + epsZ, coeffs);
  const float minZ = shFunctions(p - epsZ, coeffs);

  return make_vec3f(plusX-minX, plusY-minY, plusZ-minZ);
}

struct complex {
float real;
float imaginary;
};

struct complex plus(const struct complex& a, const struct complex& b)
{
  complex c;
  c.real = a.real + b.real;
  c.imaginary = a.imaginary + b.imaginary;
  return c;
}

struct complex plus(const struct complex& a, float b)
{
  complex c;
  c.real = a.real + b;
  c.imaginary = a.imaginary;
  return c;
}

struct complex minus(const struct complex& a, const struct complex& b)
{
  complex c;
  c.real = a.real - b.real;
  c.imaginary = a.imaginary - b.imaginary;
  return c;
}

struct complex minus(const struct complex& a, float b)
{
  complex c;
  c.real = a.real - b;
  c.imaginary = a.imaginary;
  return c;
}

struct complex times(const struct complex& a, const struct complex& b)
{
  complex c;
  c.real = a.real * b.real - a.imaginary * b.imaginary;
  c.imaginary = a.real * b.imaginary + a.imaginary * b.real;
  return c;
}

struct complex times(const struct complex& a, float b)
{
  complex c;
  c.real = a.real * b;
  c.imaginary = a.imaginary * b;
  return c;
}

struct complex conj(const struct complex& a)
{
  complex b;
  b.real = a.real;
  b.imaginary = -a.imaginary;
  return b;
}

struct complex divide(const struct complex& a, const struct complex& b)
{
  struct complex ret;
  float denom = (b.real*b.real+b.imaginary*b.imaginary);
  ret.real = (a.real*b.real + a.imaginary*b.imaginary) / denom;
  ret.imaginary = (a.imaginary*b.real - a.real*b.imaginary) / denom;
  return ret;
}

struct complex divide(float a, const struct complex& b)
{
  struct complex ret;
  float denom = (b.real*b.real+b.imaginary*b.imaginary);
  ret.real = (a*b.real) / denom;
  ret.imaginary = (-a*b.imaginary) / denom;
  return ret;
}

float abs(const struct complex& a)
{
  return sqrt(a.real*a.real+a.imaginary*a.imaginary);
}

struct complex sqrt(const struct complex& a)
{
  float z = abs(a);
  complex c;
  c.real = sqrt(0.5f*(z+a.real));
  c.imaginary = sqrt(0.5f*(z-a.real));
  return c;
}

inline struct complex polar(float r, float theta) {
  struct complex ret = {r * cos(theta), r * sin(theta)};
  return ret;
}

// length can be less than 10
inline void laguer(const complex a[11], struct complex& x, int length)
{
  const static int MR = 8;
  const static int MT = 10;
  const static int MAXIT = MR*MT;
  const static float EPS = 1.0e-6;
  const float frac[9] = {0.0, 0.5, 0.25, 0.75, 0.13, 0.38, 0.62, 0.88, 1.0};

  complex dx = {0.f, 0.f};
  complex x1 = {0.f, 0.f};
  complex b = {0.f, 0.f};
  complex d = {0.f, 0.f};
  complex f = {0.f, 0.f};
  complex g = {0.f, 0.f};
  complex h = {0.f, 0.f};
  complex sq = {0.f, 0.f};
  complex gp = {0.f, 0.f};
  complex gm = {0.f, 0.f};
  complex g2 = {0.f, 0.f};
  const int m = length-1; // number of coefficients minus 1

  for (int iter = 1; iter < MAXIT+1; iter++) {
    b = a[m];
    float err = abs(b);
    float abx = abs(x);
    d.real = 0;
    d.imaginary = 0;
    f.real = 0;
    f.imaginary = 0;
    for(int j=m-1; j > -1; j--) {
      f = plus(times(x,f), d);
      d = plus(times(x,d), b);
      complex a_val = a[j];
      b = plus(times(x,b), a_val);
      err = abs(b) + abx*err;
    }
    err *= EPS;

    if (abs(b) <= err) return;
    g = divide(d,b);
    g2 = times(g,g);
    h = minus(g2, times(divide(f,b), 2.f));
    sq = sqrt(times(minus(times(h, (float)m), g2), (float)(m-1)));
    gp = plus(g, sq);
    gm = minus(g, sq);
    float abp = abs(gp);
    float abm = abs(gm);
    if (abp < abm) gp=gm;
    dx = max(abp, abm) > 0.f ? divide(m, gp) : polar(1.f+abx, (float)iter);
    x1 = minus(x, dx);
    if (x.real == x1.real && x.imaginary == x1.imaginary) return;
    if (iter % MT != 0) x = x1;
    else x = minus(x, times(dx, frac[(int)(iter/MT)]));
  }
}

struct ortho_frame {
  linear2f frame_to_ray_space;
  vec3f closest_dir;
  float closest_dist;
};

ortho_frame get_orthonormal_frame(vec3f glyph_center, vec3f ray_origin, vec3f ray_dir)
{
    /*
    Produces an orthonormal coordinate frame for the plane that contains the
    given two points and the ray direction. All inputs are arrays of shape
    (3, ...).
    :param glyph_center: The center position of the SH glyph.
    :param ray_origin: The origin of the ray being traced.
    :param ray_dir: The normalized ray direction vector.
    :return: A tuple (frame_to_ray_space, ray_dir, closest_dir, closest_dist).
        ray_dir is simply passed through. closest_dir is an array of shape
        (3, ...) providing the normalized direction from glyph_center to the
        closest point on the ray and closest_dist (shape (...)) provides the
        corresponding distance. Together the two vectors form an orthonormal
        frame. frame_to_ray_space is a matrix of shape (2, 2, ...). It converts
        from a coordinate frame where the x-axis corresponds to ray_dir and the
        y-axis corresponds to closest_dir to a coordinate frame where the x-axis
        corresponds to ray_dir and the y-axis corresponds to
        ray_origin - glyph_center.
    */
    struct ortho_frame frame;
    vec3f offset = ray_origin - glyph_center;
    float ray_dot_offset = dot(ray_dir, offset);
    frame.closest_dir = offset - ray_dot_offset * ray_dir;
    frame.closest_dist = length(frame.closest_dir);
    float inv_closest_dist = 1.0 / frame.closest_dist;
    frame.closest_dir = frame.closest_dir * inv_closest_dist;
    frame.frame_to_ray_space.vx = make_vec2f(1.0, 0.0);
    frame.frame_to_ray_space.vy = make_vec2f(-inv_closest_dist * ray_dot_offset, inv_closest_dist);
    return frame;
}

void rootsToRaySpace(complex roots[11], float ray_roots[11], ortho_frame &frame) {
  for (int i = 0; i < 11; ++i) {
    vec2f v = make_vec2f(roots[i].real, 1.0);
    v = frame.frame_to_ray_space * v;
    ray_roots[i] = v.x / v.y;
  }
}

void filterRealRoots(complex roots[11], float ray_roots[11],
    varying SHIntersections* uniform hitData) {

  for (uniform int i = 0; i < 11; ++i) {
    if (abs(roots[i].imaginary) < 1.0e-5)
      hitData->roots[hitData->numIntersections++] = ray_roots[i];
  }
}

void evaluate_sh_4(float point[3][5], bool evaluate_gradient, bool evaluate_hessian, float sh[5][15]) {
    /*
    Evaluates spherical harmonics basis functions in bands 0, 2 and 4. For the
    most part, it follows the conventions of "Stupid Spherical Harmonics (SH)
    Tricks" by Peter-Pike Sloan 2008:
    https://www.ppsloan.org/publications/StupidSH36.pdf
    For normalized vectors, results are the same as with the formulas in this
    work. The major difference is that the polynomials have been made
    homogeneous of degree 4, i.e. scaling point by a factor r scales the SH
    basis functions by a factor of r^4 and their gradient by r^3.
    :param point: An array of shape (3, ...) providing the Cartesian coordinates
        at which the spherical harmonics basis functions should be evaluated.
    :param evaluate_gradient: Pass True to also evaluate the gradient of the SH
        basis functions.
    :param evaluate_hessian: Pass True to also evaluate the Hessian matrix of
        the SH basis functions. Implies evaluate_gradient.
    :return: The requested arrays from the set sh, gradient, hessian in this
        order. sh has shape (15, ...). gradient has shape (3, 15, ...), where
        the first dimension corresponds to the three dimensions along which the
        derivative can be taken. hessian has shape (6, 15, ...) where the first
        dimension corresponds to the entries [0, 0], [0, 1], [0, 2], [1, 1],
        [1, 2], [2, 2] of the symmetric matrix. The dimension of length 15 lists
        SH basis functions ordered by band. That means the index tuples
        (band, order) are as follows:
        [0] -> (0, 0)
        [1] -> (2, -2)
        [2] -> (2, -1)
        [3] -> (2, 0)
        [4] -> (2, 1)
        [5] -> (2, 2)
        [6] -> (4, -4)
        [7] -> (4, -3)
        [8] -> (4, -2)
        [9] -> (4, -1)
        [10] -> (4, 0)
        [11] -> (4, 1)
        [12] -> (4, 2)
        [13] -> (4, 3)
        [14] -> (4, 4)
    */
    // This initial part is rather NumPy specific but everything else should be
    // easy to port to other languages
    /* int shape = sizeof(point)/sizeof(point[0]) / 3; */
    #define shape 5 // TODO undo hardcode
    /* float sh[5 * 15]; */
    // For homogenization, we express the associated Legendre polynomials as
    // homogeneous polynomials of the variables z and r = sqrt(x^2 + y^2)
    /* #define x point[0] */
    /* float* x = &point[0]; */
    /* float* y = &point[1]; */
    /* float* z = &point[2]; */

    float z_2[shape];
    float r_2[shape];
    for (int i = 0; i < shape; ++i) {
      z_2[i] = point[2][i] * point[2][i];
      r_2[i] = point[0][i] * point[0][i] + point[1][i] * point[1][i];
    }
    // Evaluate the relevant associated Legendre polynomials. At such low degree,
    // the recurrent scheme is not worthwhile. We skip odd bands and constant or
    // linear polynomials.
    float legendre_4_0[shape];
    float scaled_legendre_4_1[shape];
    float scaled_legendre_4_2[shape];
    float cosine_2[shape];
    float sine_2[shape];
    float cosine_3[shape];
    float sine_3[shape];
    float cosine_4[shape];
    float sine_4[shape];
    float one_2[shape];
    for (int i = 0; i < shape; ++i) {
      legendre_4_0[i] = z_2[i] * (z_2[i] - 3.0*r_2[i]) + 3.0/8.0 * r_2[i] * r_2[i];
      scaled_legendre_4_1[i] = 2.67618617422915667 * point[2][i] * (-z_2[i] + 0.75 * r_2[i]);
      scaled_legendre_4_2[i] = 2.83852408727268005 * (z_2[i] - (1.0 / 6.0) * r_2[i]);
      // Evaluate the Fourier basis. Again, we omit constant and linear terms.
      cosine_2[i] = r_2[i] - 2.0 * point[1][i] * point[1][i];
      sine_2[i] = 2.0 * point[0][i] * point[1][i];
      cosine_3[i] = point[0][i] * cosine_2[i] - point[1][i] * sine_2[i];
      sine_3[i] = point[0][i] * sine_2[i] + point[1][i] * cosine_2[i];
      cosine_4[i] = point[0][i] * cosine_3[i] - point[1][i] * sine_3[i];
      sine_4[i] = point[0][i] * sine_3[i] + point[1][i] * cosine_3[i];
      // Assemble the Legendre polynomials and the Fourier basis with appropriate
      // constant factors and homogenize to degree 4 by multiplying one_2 as needed
      one_2[i] = r_2[i] + z_2[i];
      sh[i][0] = 0.282094791773878143 * one_2[i] * one_2[i];
      sh[i][1] = 0.546274215296039535 * one_2[i] * sine_2[i];
      sh[i][2] = -1.09254843059207907 * one_2[i] * point[1][i] * point[2][i];
      sh[i][3] = 0.630783130505040012 * one_2[i] * (z_2[i] - 0.5 * r_2[i]);
      sh[i][4] = -1.09254843059207907 * one_2[i] * point[0][i] * point[2][i];
      sh[i][5] = 0.546274215296039535 * one_2[i] * cosine_2[i];
      sh[i][6] = 0.625835735449176135 * sine_4[i];
      sh[i][7] = -1.77013076977993053 * sine_3[i] * point[2][i];
      sh[i][8] = sine_2[i] * scaled_legendre_4_2[i];
      sh[i][9] = point[1][i] * scaled_legendre_4_1[i];
      sh[i][10] = 0.846284375321634430 * legendre_4_0[i];
      sh[i][11] = point[0][i] * scaled_legendre_4_1[i];
      sh[i][12] = cosine_2[i] * scaled_legendre_4_2[i];
      sh[i][13] = -1.77013076977993053 * cosine_3[i] * point[2][i];
      sh[i][14] = 0.625835735449176135 * cosine_4[i];
    }
    /* if (!evaluate_gradient && !evaluate_hessian) */
      /* return sh; */
}

void evaluate_sh_4(float point[3][5],  float sh[5][15]) { evaluate_sh_4(point, false, false, sh); }

float* get_planar_sh_polynomial_4(const uniform float* sh_coeffs, vec3f x_axis, vec3f y_axis, float sh_poly[5]) {
    /*
    Constructs a homogeneous quartic polynomial in the monic basis describing
    the behavior of a linear combination of SH basis functions in bands 0, 2, 4
    in a plane spanned by two given vectors.
    :param sh_coeffs: Spherical harmonics coefficients for bands 0, 2 and 4. See
        evaluate_sh_4() for their order. Array of shape (15, ...).
    :param x_axis: The x-axis of the coordinate frame. Array of shape (3, ...).
    :param y_axis: The y-axis of the coordinate frame. Array of shape (3, ...).
    :return: Polynomial coefficients for y^4, y^3*x, y^2*x^2, y*x^3, x^4 in this
        order. Array of shape (5, ...).
    */
    // Evaluate at fixed pairs of x and y. These points are rather arbitrary. The
    // main goals in choosing them are that the computation of polynomial
    // coefficients is fast and numerically stable. See invert_vandermonde().
    const uniform float xs[] = {-pow(0.5,0.25), pow(0.5,0.25), 2.0, 0.0, 1.0};
    const uniform float ys[] = { pow(0.5,0.25), pow(0.5,0.25), 1.0, 1.0, 0.0};
    float points[3][5];
    for (uniform int i = 0; i < 3; ++i)
      for (uniform int j = 0; j < 5; ++j)
        points[i][j] = xs[j] * get(x_axis, i) + ys[j] * get(y_axis, i);

    float shs[5][15];
    evaluate_sh_4(points, shs);
    float poly_values[5] = {0};
    for (uniform int i = 0; i < 5; ++i) {
      sh_poly[i] = 0;
    /* print("shs %d\n", shs[i][0]); */
      for (uniform int j = 0; j < 15; ++j)
        poly_values[i] += shs[i][j] * sh_coeffs[j];
    }

    // Construct the polynomial coefficients
    sh_poly[0] = poly_values[3];
    sh_poly[4] = poly_values[4];
    const uniform float inv_vander[3][5] = {{-2.0 / 3.0, 2.0, -1.0 / 6.0, -0.5, 2.0},
                                            {1.0, 1.0, 0.0, -1.0, -1.0},
                                            {-1.0 / 3.0, -1.0, 1.0 / 6.0, 0.5, -2.0}};
    for (uniform int i = 1; i < 4; ++i)
      for (uniform int j = 0; j < 5; ++j)
        sh_poly[i] += inv_vander[i-1][j] * poly_values[j];
}

void zroots(float a[11], complex roots[11], bool polish, vec3f& debug_col) {
    float EPS = 1.0e-14;
    const uniform int m = 10;
    complex x = {0,0};
    complex b = {0,0};
    complex c = {0,0};
    // default root values need to avoid stopping criteria(imag == 0 in our case)
    for (uniform int i = 0; i < 11; ++i) {
      roots[i].real = 1e16;
      roots[i].imaginary = 1e16;
    }
    complex a_complex[11];
    complex ad[11];
    for (uniform int i = 0; i < 11; ++i) {
      ad[i].real = a[i];
      ad[i].imaginary = 0;
      a_complex[i].real = a[i];
      a_complex[i].imaginary = 0;
    }
    for (uniform int j = m-1; j > -1; --j) { // loop over each root to be found
      x.real = 0.0;
      x.imaginary = 0.0; // start at zero to favor convergence to smallest remaining root
      laguer(ad, x, j+2);
      if (abs(x.imaginary) <= 2.0*EPS*abs(x.real))
        x.imaginary = 0.0;
      roots[j] = x;
      b = ad[j+1]; // forward deflation
      for (int jj = j; jj > -1; --jj) {
        c = ad[jj];
        ad[jj] = b;
        b = plus(times(x,b),c);
      }
    }

    // polish roots using undeflated coefficients
    if (polish)
        for (uniform int j = 0; j < 11; ++j)
            laguer(a_complex, roots[j], 11);

    // sort roots by real parts by straight insertion
    for (uniform int i = 1; i < m; ++i) {
      complex temp = roots[i];
      int j = i;
      while (j > 0 && roots[j-1].real > temp.real) {
        roots[j] = roots[j-1];
        j -= 1;
      }
      roots[j] = temp;
    }
    debug_col.x = roots[0].real;
    /* debug_col.y = roots[1].real; */
    /* debug_col.z = roots[2].real; */
}

float* get_poly(const uniform float* sh_coeffs, vec3f ray_dir, struct ortho_frame frame, float poly[11], vec3f& debug_col) {
    float sh_poly[5];
    get_planar_sh_polynomial_4(sh_coeffs, ray_dir, frame.closest_dir, sh_poly);
    // Square this polynomial
    float sh_square[9] = {0};
    for (int i = 0; i < 9; ++i)
      for (int j = max(0, i-4); j < min(4,i)+1; ++j)
        sh_square[i] += sh_poly[j] * sh_poly[i - j];
    // Increase the degree of the polynomial from 8 to 10 assuming y=closest_dist
    float inv_dist_sq = 1.0 / (frame.closest_dist * frame.closest_dist);
    for (uniform int i = 0; i < 9; ++i)
      poly[i] = inv_dist_sq * sh_square[i];
    poly[9] = poly[10] = 0;
    // Subtract (x^2+y^2)^5 (which can be computed using the binomial theorem)
    poly[0] -= 1.0;
    poly[2] -= 5.0;
    poly[4] -= 10.0;
    poly[6] -= 10.0;
    poly[8] -= 5.0;
    poly[10] -= 1.0;
}

/* void get_sh_glyph_intersections(float** sh_coeffs, vec3f glyph_center, vec3f ray_origin, vec3f ray_dir) */
/* { */
/*     /\* */
/*     Computes all intersections between a ray and a glyph defined by a linear */
/*     combination of spherical harmonics basis functions. */
/*     :param sh_coeffs: Spherical harmonics coefficients for bands 0, 2 and 4. See */
/*         evaluate_sh_4() for their order. Shape 15. */
/*     :param glyph_center: The center position of the SH glyph. Shape 3. */
/*     :param ray_origin: The origin of the ray being traced. Shape 3. */
/*     :param ray_dir: The normalized ray direction vector. Shape 3. */
/*     :return: An array of shape 10 providing ray parameters at which */
/*         intersections exist. Some of them may be complex or negative. */
/*     *\/ */
/*     // Get a polynomial for the SH polynomial in the relevant plane */
/*     struct ortho_frame* frame = get_orthonormal_frame(glyph_center, ray_origin, ray_dir); */
/*     float* poly = get_poly(sh_coeffs, ray_dir, frame); */

/*     // Numpy does not have a handy function to compute roots for many polynomials */
/*     // in an array at once, hence I lost my motivation to vectorize things */
/*     float roots[11];
/*     zroots(poly, roots, true); */
/*     // Transform back to ray coordinates. We could have worked in global */
/*     // coordinates directly but this approach ought to be more stable. */
/*     float* ray_roots[length(roots)]; */
/*     for (int i = 0; i < length(roots); ++i) */
/*       ray_roots = frame->frame_to_ray_space * np.vstack([roots, np.ones_like(roots)]); */
/*     // Dehomogenize */
/*     return ray_roots[0] / ray_roots[1]; */
/* } */

float eval_poly(float poly[11], float t) {
  float y = 0.f;
  uniform int degree = 10; // TODO undo hardcode
  float t_pow = t;
  y += poly[0];
  for (uniform int i = 1; i < degree+1; ++i) {
    y += poly[i] * t_pow;
    t_pow *= t;
  }
  //y += poly[degree];
  return y;
}


// code for inverse rotation method
void RealWignerZRotation0(uniform float* coefficients, float angle)
{
	// Nothing to do for 0th order SH.
	return;
}

void RealWignerZRotation2(uniform float* coefficients, float angle)
{
	// Local copy of second-order coefficients
	float a[5];

	// Copy coefficients
	for (int i = 0; i < 5; i++)
	{
		a[i] = coefficients[i];
	}

	// Pre-compute sines and cosines
	float c1 = cos(angle);
	float c2 = cos(2.0 * angle);
	float s1 = sin(angle);
	float s2 = sin(2.0 * angle);

	// Compute output coefficients
	coefficients[0] = a[0] * c2 + a[4] * s2;
	coefficients[1] = a[1] * c1 - a[3] * s1;
	coefficients[2] = a[2];
	coefficients[3] = a[3] * c1 + a[1] * s1;
	coefficients[4] = a[4] * c2 - a[0] * s2;
}

void RealWignerZRotation4(uniform float* coefficients, float angle)
{
	// Local copy of fourth-order coefficients
	float a[9];

	// Copy coefficients
	for (int i = 0; i < 9; i++)
	{
		a[i] = coefficients[i];
	}

	// Pre-compute sines and cosines
	float c1 = cos(angle);
	float c2 = cos(2.0 * angle);
	float c3 = cos(3.0 * angle);
	float c4 = cos(4.0 * angle);
	float s1 = sin(angle);
	float s2 = sin(2.0 * angle);
	float s3 = sin(3.0 * angle);
	float s4 = sin(4.0 * angle);

	// Compute output coefficients
	coefficients[0] = a[0] * c4 + a[8] * s4;
	coefficients[1] = a[1] * c3 - a[7] * s3;
	coefficients[2] = a[2] * c2 + a[6] * s2;
	coefficients[3] = a[3] * c1 - a[5] * s1;
	coefficients[4] = a[4];
	coefficients[5] = a[5] * c1 + a[3] * s1;
	coefficients[6] = a[6] * c2 - a[2] * s2;
	coefficients[7] = a[7] * c3 + a[1] * s3;
	coefficients[8] = a[8] * c4 - a[0] * s4;
}

void RealWignerZRotation(uniform float* coefficients, float angle)
{
	// Do nothing if the angle is zero
	if (angle == 0.0)
		return;

	// Compute new coefficient values
	RealWignerZRotation0(&coefficients[0], angle);
	RealWignerZRotation2(&coefficients[1], angle);
	RealWignerZRotation4(&coefficients[6], angle);
}

void RealWignerYRotation0(uniform float* coefficients, float angle)
{
	// Nothing to do for 0th order SH.
	return;
}

void RealWignerYRotation2(uniform float* coefficients, float angle)
{
	// Local copy of second-order coefficients
	float a[5];

	// Copy coefficients
	for (int i = 0; i < 5; i++)
	{
		a[i] = coefficients[i];
	}

	// Pre-compute sines and cosines
	float c1 = cos(angle);
	float c2 = cos(2.0 * angle);
	float s1 = sin(angle);
	float s2 = sin(2.0 * angle);

	// Compute output coefficients
	coefficients[0] = (3 * a[0] + sqrtf(3) * a[2] + a[0] * c2 - sqrtf(3) * a[2] * c2 - 2 * a[1] * s2) / 4.0;
	coefficients[1] = (2 * a[1] * c2 + a[0] * s2 - sqrtf(3) * a[2] * s2) / 2.0;
	coefficients[2] = (sqrtf(3) * a[0] + a[2] - sqrtf(3) * a[0] * c2 + 3 * a[2] * c2 + 2 * sqrtf(3) * a[1] * s2) / 4.0;
	coefficients[3] = a[3] * c1 - a[4] * s1;
	coefficients[4] = a[4] * c1 + a[3] * s1;
}

void RealWignerYRotation4(uniform float* coefficients, float angle)
{
	// Local copy of fourth-order coefficients
	float a[9];

	// Copy coefficients
	for (int i = 0; i < 9; i++)
	{
		a[i] = coefficients[i];
	}

	// Pre-compute sines and cosines
	float c1 = cos(angle);
	float c2 = cos(2.0 * angle);
	float c3 = cos(3.0 * angle);
	float c4 = cos(4.0 * angle);
	float s1 = sin(angle);
	float s2 = sin(2.0 * angle);
	float s3 = sin(3.0 * angle);
	float s4 = sin(4.0 * angle);

	// Compute output coefficients
	coefficients[0] = (35*a[0] + 10*sqrtf(7)*a[2] + 3*sqrtf(35)*a[4] + 28*a[0]*c2 - 8*sqrtf(7)*a[2]*c2 - 4*sqrtf(35)*a[4]*c2 + a[0]*c4 - 2*sqrtf(7)*a[2]*c4 + sqrtf(35)*a[4]*c4 - 28*sqrtf(2)*a[1]*s2 - 4*sqrtf(14)*a[3]*s2 - 2*sqrtf(2)*a[1]*s4 + 2*sqrtf(14)*a[3]*s4)/64.0;
	coefficients[1] = (28*a[1]*c2 + 4*sqrtf(7)*a[3]*c2 + 4*a[1]*c4 - 4*sqrtf(7)*a[3]*c4 + 14*sqrtf(2)*a[0]*s2 - 4*sqrtf(14)*a[2]*s2 - 2*sqrtf(70)*a[4]*s2 + sqrtf(2)*a[0]*s4 - 2*sqrtf(14)*a[2]*s4 + sqrtf(70)*a[4]*s4)/32.0;
	coefficients[2] = (5*sqrtf(7)*a[0] + 10*a[2] + 3*sqrtf(5)*a[4] - 4*sqrtf(7)*a[0]*c2 + 8*a[2]*c2 + 4*sqrtf(5)*a[4]*c2 - sqrtf(7)*a[0]*c4 + 14*a[2]*c4 - 7*sqrtf(5)*a[4]*c4 + 4*sqrtf(14)*a[1]*s2 + 4*sqrtf(2)*a[3]*s2 + 2*sqrtf(14)*a[1]*s4 - 14*sqrtf(2)*a[3]*s4)/32.0;
	coefficients[3] = (4*sqrtf(7)*a[1]*c2 + 4*a[3]*c2 - 4*sqrtf(7)*a[1]*c4 + 28*a[3]*c4 + 2*sqrtf(14)*a[0]*s2 - 4*sqrtf(2)*a[2]*s2 - 2*sqrtf(10)*a[4]*s2 - sqrtf(14)*a[0]*s4 + 14*sqrtf(2)*a[2]*s4 - 7*sqrtf(10)*a[4]*s4)/32.0;
	coefficients[4] = (3*sqrtf(35)*a[0] + 6*sqrtf(5)*a[2] + 9*a[4] - 4*sqrtf(35)*a[0]*c2 + 8*sqrtf(5)*a[2]*c2 + 20*a[4]*c2 + sqrtf(35)*a[0]*c4 - 14*sqrtf(5)*a[2]*c4 + 35*a[4]*c4 + 4*sqrtf(70)*a[1]*s2 + 4*sqrtf(10)*a[3]*s2 - 2*sqrtf(70)*a[1]*s4 + 14*sqrtf(10)*a[3]*s4)/64.0;
	coefficients[5] = (9*a[5]*c1 + 3*sqrtf(7)*a[7]*c1 + 7*a[5]*c3 - 3*sqrtf(7)*a[7]*c3 - 3*sqrtf(2)*a[6]*s1 - 3*sqrtf(14)*a[8]*s1 - 7*sqrtf(2)*a[6]*s3 + sqrtf(14)*a[8]*s3)/16.0;
	coefficients[6] = (2*a[6]*c1 + 2*sqrtf(7)*a[8]*c1 + 14*a[6]*c3 - 2*sqrtf(7)*a[8]*c3 + 3*sqrtf(2)*a[5]*s1 + sqrtf(14)*a[7]*s1 + 7*sqrtf(2)*a[5]*s3 - 3*sqrtf(14)*a[7]*s3)/16.0;
	coefficients[7] = (3*sqrtf(7)*a[5]*c1 + 7*a[7]*c1 - 3*sqrtf(7)*a[5]*c3 + 9*a[7]*c3 - sqrtf(14)*a[6]*s1 - 7*sqrtf(2)*a[8]*s1 + 3*sqrtf(14)*a[6]*s3 - 3*sqrtf(2)*a[8]*s3)/16.0;
	coefficients[8] = (2*sqrtf(7)*a[6]*c1 + 14*a[8]*c1 - 2*sqrtf(7)*a[6]*c3 + 2*a[8]*c3 + 3*sqrtf(14)*a[5]*s1 + 7*sqrtf(2)*a[7]*s1 - sqrtf(14)*a[5]*s3 + 3*sqrtf(2)*a[7]*s3)/16.0;

	return;
}

void RealWignerYRotation(uniform float* coefficients, float angle)
{
	// Do nothing if the angle is zero
	if (angle == 0.0)
		return;

	// Compute new coefficient values
	RealWignerYRotation0(&coefficients[0], angle);
	RealWignerYRotation2(&coefficients[1], angle);
	RealWignerYRotation4(&coefficients[6], angle);
}

float CylinderRhoMax(int l, int m)
{
	// Output value
	float result = 0.0;

	// Hard-coded results for all combinations of "l" and "m"
	     if ((l == 0) && (m ==  0))		result = 0.282095;
	else if ((l == 2) && (m == -2))		result = 0.386274;
	else if ((l == 2) && (m == -1))		result = 0.297354;
	else if ((l == 2) && (m ==  0))		result = 0.315392;
	else if ((l == 2) && (m ==  1))		result = 0.297354;
	else if ((l == 2) && (m ==  2))		result = 0.386274;
	else if ((l == 4) && (m == -4))		result = 0.442533;
	else if ((l == 4) && (m == -3))		result = 0.358249;
	else if ((l == 4) && (m == -2))		result = 0.334523;
	else if ((l == 4) && (m == -1))		result = 0.311653;
	else if ((l == 4) && (m ==  0))		result = 0.317357;
	else if ((l == 4) && (m ==  1))		result = 0.311653;
	else if ((l == 4) && (m ==  2))		result = 0.334523;
	else if ((l == 4) && (m ==  3))		result = 0.358249;
	else if ((l == 4) && (m ==  4))		result = 0.442533;

	return result;
}

float CylinderZMax(int l, int m)
{
	// Output value
	float result = 0.0;

	// Hard-coded results for all combinations of "l" and "m"
	     if ((l == 0) && (m ==  0))		result = 0.282095;
	else if ((l == 2) && (m == -2))		result = 0.148677;
	else if ((l == 2) && (m == -1))		result = 0.297354;
	else if ((l == 2) && (m ==  0))		result = 0.630783;
	else if ((l == 2) && (m ==  1))		result = 0.297354;
	else if ((l == 2) && (m ==  2))		result = 0.148677;
	else if ((l == 4) && (m == -4))		result = 0.126660;
	else if ((l == 4) && (m == -3))		result = 0.232690;
	else if ((l == 4) && (m == -2))		result = 0.335275;
	else if ((l == 4) && (m == -1))		result = 0.459798;
	else if ((l == 4) && (m ==  0))		result = 0.846284;
	else if ((l == 4) && (m ==  1))		result = 0.459798;
	else if ((l == 4) && (m ==  2))		result = 0.335275;
	else if ((l == 4) && (m ==  3))		result = 0.232690;
	else if ((l == 4) && (m ==  4))		result = 0.126660;

	return result;
}

float CylinderRMax(uniform float* coefficients)
{
	// Output radius
	float sumL = 0.0;

	// Sum for one order
	float sumM = 0.0;

	// Coefficient index
	int j = 0;

	// Loop through the orders
	for (int l = 0; l <= 4; l += 2) {
		// Reset the sum for this order
		sumM = 0.0;

		// Process (2*L+1) coefficients
		for (int m = -l; m <= l; m++) {
			sumM += abs(coefficients[j]) * CylinderRhoMax(l, m);
			j++;
		}
		sumL += sumM;
	}
	return sumL;
}

float CylinderZMax(uniform float* coefficients)
{
	assert(coefficients != NULL);

	// Output radius
	float sumL = 0.0;

	// Sum for one order
	float sumM = 0.0;

	// Coefficient index
	int j = 0;

	// Loop through the orders
	for (int l = 0; l <= 4; l += 2) {
		// Reset the sum for this order
		sumM = 0.0;

		// Process (2*L+1) coefficients
		for (int m = -l; m <= l; m++) {
			sumM += abs(coefficients[j]) * CylinderZMax(l, m);
			j++;
		}
		sumL += sumM;
	}
	return sumL;
}

float C0even(uniform float* coeffs, float phi) {
  return (coeffs[0] + sqrt(5.0)*coeffs[3] + 3.0*coeffs[10])/(2.0*sqrt(PI));
}

float C1even(uniform float* coeffs, float phi) {
  return (sqrt(5.0/PI)*((sqrt(3.0)*coeffs[2] + 3.0*sqrt(2.0)*coeffs[9])*cos(phi) - (sqrt(3.0)*coeffs[4] + 3.0*sqrt(2.0)*coeffs[11])*sin(phi)))/2.0;
}

float C2even(uniform float* coeffs, float phi) {
  return (4.0*coeffs[0] + sqrt(5.0)*coeffs[3] - 18.0*coeffs[10] + sqrt(5.0)*(sqrt(3.0)*coeffs[1] + 9.0*coeffs[8])*cos(2.0*phi) + sqrt(5.0)*(sqrt(3.0)*coeffs[5] + 9.0*coeffs[12])*sin(2.0*phi))/(4.0*sqrt(PI));
}

float C3even(uniform float* coeffs, float phi) {
  return (sqrt(5.0/PI)*((4.0*sqrt(3.0)*coeffs[2] - 9.0*sqrt(2.0)*coeffs[9])*cos(phi) + 3.0*sqrt(14.0)*coeffs[7]*cos(3.0*phi) - 4.0*sqrt(3.0)*coeffs[4]*sin(phi) + 9.0*sqrt(2.0)*coeffs[11]*sin(phi) - 3.0*sqrt(14.0)*coeffs[13]*sin(3.0*phi)))/8.0;
}

float C4even(uniform float* coeffs, float phi) {
  return (8.0*coeffs[0] - 4.0*sqrt(5.0)*coeffs[3] + 9.0*coeffs[10] + 2.0*sqrt(5.0)*(2.0*sqrt(3.0)*coeffs[1] - 3.0*coeffs[8])*cos(2.0*phi) + 3.0*sqrt(35.0)*coeffs[6]*cos(4.0*phi) + 2.0*sqrt(5.0)*(2.0*sqrt(3.0)*coeffs[5] - 3.0*coeffs[12])*sin(2.0*phi) + 3.0*sqrt(35.0)*coeffs[14]*sin(4.0*phi))/(16.0*sqrt(PI));
}

float Ceven(uniform float* coeffs, int lmax, float phi)
{
  float result = 0.0;
  if (lmax == 0) result = C0even(coeffs, phi);
  else if (lmax == 1) result = C1even(coeffs, phi);
  else if (lmax == 2) result = C2even(coeffs, phi);
  else if (lmax == 3) result = C3even(coeffs, phi);
  else if (lmax == 4) result = C4even(coeffs, phi);
  return result;
}

float chPolyVal(float Ce[5], float rho, float z)
{
    float sumit = 0.0;
    float zp = abs(z);
    float s;
    for (uniform int n=0; n <=4; n++)
      {
      // XXX: There is a problem for z < 0. The code below fixes this but its not ideal.
      //  It would be better to fix the IsInsideCylindricalHarmonic for negative z.
      if ((z < 0.0) && ((n==1)||(n==3))) s = -1.0;
      else s = 1.0;
      sumit += Ce[n]*pow(rho, (float)n)*pow(zp, (float)(4-n))*s;
      } // for n
    //if (sumit > pow(sqrt(rho*rho+zp*zp), 5.0)) isInside = true;
    //else isInside = false;
    return sumit - pow(sqrt(rho*rho+zp*zp), 5.0);
}

inline Intersections intersectSphericalHarmonics(const vec3f& rayOrg,
    const vec3f& rayDir,
    const uniform vec3f& center,
    const uniform float* coeffs,
    const uniform int degreeL,
    const uniform float boundRadius,
    varying SHIntersections* uniform hitData)
{
  Intersections isect;
  isect.entry.hit = false;
  isect.exit.hit = false;
  isect.entry.t = inf;
  isect.exit.t = -inf;
  bool hitDataPresent = hitData != NULL;
  if (hitDataPresent && hitData->numIntersections != 0) return isect;

  vec3f cRayOrg = rayOrg - center;

  // bounding sphere as starting point
  Intersections isectSphere = intersectSphere(cRayOrg, rayDir, make_vec3f(0.f, 0.f, 0.f), boundRadius);
  float dist = isectSphere.entry.t;
  float max_dist = isectSphere.exit.t;
  float step_size = boundRadius * 2.f / (float)STEPS_;

	vec3f res = make_vec3f(1e10,-1.0, 1.0);

  float h = 1.0;
  vec2f m = make_vec2f(-1.0);
  vec3f s;
  int stepTotal = 0;
  vec3f p;
  #if 1
  vec3f debug_col = make_vec3f(0);
  float io;
  struct ortho_frame frame = get_orthonormal_frame(center, rayOrg, rayDir);
  float poly[11];
  get_poly(coeffs, rayDir, frame, poly, debug_col);
  complex roots[11];
  zroots(poly, roots, false, debug_col);
  float ray_roots[11];
  rootsToRaySpace(roots, ray_roots, frame);
  if (hitDataPresent) {
    filterRealRoots(roots, ray_roots, hitData);
    hitData->numIntersections = 1; // hard code to 1 so always visualizing a value
    for (int i = 0; i < hitData->numIntersections > 0; ++i)
      hitData->normals[i] = get_sh_glyph_normal(coeffs, cRayOrg + hitData->roots[i] * rayDir);
    hitData->roots[1] = debug_col.x;
    hitData->roots[2] = debug_col.y;
    hitData->roots[3] = debug_col.z;
  }
  else {
    for (uniform int i = 0; i < 11; ++i)
      if (abs(roots[i].imaginary) < 1.0e-5) {
        dist = ray_roots[i];
        isect.entry.hit = true;
        break;
      }
  }

  if(isect.entry.hit) {
    isect.entry.u = ray_roots[0];
    isect.entry.t = dist;
    p = cRayOrg + dist * rayDir;
    isect.entry.N = get_sh_glyph_normal(coeffs, p);
  }

  return isect;


  #elif 0 // inverse rotation method
  vec3f eyeposT = cRayOrg - center; // TODO double check this
  vec3f viewUp = make_vec3f(0.0,1.0,0.0);
  vec3f eZ = normalize(eyeposT);
	vec3f eX = normalize(cross(viewUp, eZ)); // TODO pass viewUp
  vec3f eY = normalize(cross(eZ, eX));
  float gamma = atan2(eY.z, -1.0 * eX.z);
  float beta  = atan2(sqrt(eX.z * eX.z + eY.z * eY.z), eZ.z);
  float alpha = atan2(eZ.y, eZ.x);
  uniform float* coeffsCopy = new float[15];
  for (uniform int i = 0; i < 15; ++i)
    coeffsCopy[i] = coeffs[i];

  float zrot = 0.0f;
  float yrot = 0.0f;
  RealWignerZRotation(coeffsCopy, zrot);
  RealWignerYRotation(coeffsCopy, yrot);

  // Rotate around Z-axis.
  vec3f e = eyeposT;
  eyeposT.x = e.x * cos(alpha) + e.y * sin(alpha);
  eyeposT.y = e.y * cos(alpha) - e.x * sin(alpha);

  // Rotate around Y-axis
  e = eyeposT;
  eyeposT.x = e.x * cos(beta) - e.z * sin(beta);
  eyeposT.z = e.z * cos(beta) + e.x * sin(beta);

  // Rotate around z-axis
  e = eyeposT;
  eyeposT.x = e.x * cos(gamma) + e.y * sin(gamma);
  eyeposT.y = e.y * cos(gamma) - e.x * sin(gamma);


	RealWignerZRotation(coeffsCopy, alpha);
	RealWignerYRotation(coeffsCopy, beta);
	RealWignerZRotation(coeffsCopy, gamma);
	float cylRhoMax = CylinderRMax(coeffsCopy);
	float cylZMax   = CylinderZMax(coeffsCopy);

  p = cRayOrg + dist * rayDir;
  float rho = sqrt(p.x*p.x+p.y*p.y);
  float z = p.z;
  float phi = atan2(rayDir.x,rayDir.y);
  float C[5];
  C[0] = C0even(coeffsCopy, phi);
  C[1] = C1even(coeffsCopy, phi);
  C[2] = C2even(coeffsCopy, phi);
  C[3] = C3even(coeffsCopy, phi);
  C[4] = C4even(coeffsCopy, phi);

  float r = min(cylRhoMax, max_dist);

  float io = chPolyVal(C, rho, z);
  bool movePos = io > 0;
  for( int step=0; step<STEPS_; step++) {
    stepTotal = step;
    if (abs(io) < EPSILON)
      break;
    p = cRayOrg + dist * rayDir;
    if ((movePos && io < 0) ||(!movePos && io > 0)) {
      step_size = -0.5 * step_size;
      movePos = !movePos;
    }
    io = chPolyVal(C, rho, z);

    dist += step_size;
  }

  #elif 0
  p = cRayOrg + dist * rayDir;
  float io = shFunctions(p, coeffs);
  bool movePos = io > 0;
  for( int step=0; step<STEPS_; step++) {
    stepTotal = step;
    if (abs(io) < EPSILON)
      break;
    p = cRayOrg + dist * rayDir;
    if ((movePos && io < 0) ||(!movePos && io > 0)) {
      step_size = -0.5 * step_size;
      movePos = !movePos;
    }
    io = shFunctions(p, coeffs);

    dist += step_size;
  }
  #else
  vec3f gradient;
  float io = 100.f;
  float f = 100.f;
  isect.entry.u = 0.0;
  for(int step=0; step<STEPS_; step++) {
    if (step == STEPS_-1) return isect;
    if (dist > max_dist) return isect;
    if(abs(io) < EPSILON) break;
    p = cRayOrg + dist * rayDir;
    io = shFunctions(p, coeffs);
    dist += io*0.15;
    isect.entry.u = (float)step/(float)STEPS_;
    isect.entry.u = shFunctions(p, coeffs);
  }
  #endif
  isect.entry.hit = abs(io) < EPSILON;
  /* isect.entry.hit = true; */
  isect.entry.t = dist;
  isect.entry.N = normalize(SHGradient(p, coeffs));
  isect.entry.u = (float)stepTotal/(float)STEPS_;

  return isect;
}

bool assertEqual(struct complex& res, struct complex& expected, float epsilon) {
  assert(abs(res.real-expected.real) < epsilon);
  assert(abs(res.imaginary-expected.imaginary) < epsilon);
}

void testComplexMath()
{
  struct complex a, b, expected;
  a.real = 3.2;
  a.imaginary = 2.9;
  b.real = 1.7;
  b.imaginary = 7.6;
  expected.real = 4.9;
  expected.imaginary = 10.5;

  struct complex res = plus(a, b);
  assertEqual(res, expected, 1.0e-16);

  res = plus(a, b.real);
  expected.imaginary = a.imaginary;
  assertEqual(res, expected, 1.0e-16);

  res = minus(a, b);
  expected.real = 1.5;
  expected.imaginary = -4.7;
  assertEqual(res, expected, 1.0e-16);

  res = minus(a, b.real);
  expected.imaginary = a.imaginary;
  assertEqual(res, expected, 1.0e-16);

  res = times(a, b);
  expected.real = -16.6;
  expected.imaginary = 29.25;
  assertEqual(res, expected, 1.0e-16);

  res = times(a, b.real);
  expected.real = 5.44;
  expected.imaginary = 4.93;
  assertEqual(res, expected, 1.0e-6);

  res = conj(a);
  expected.real = a.real;
  expected.imaginary = -a.imaginary;
  assertEqual(res, expected, 1.0e-16);

  res = divide(a, b);
  expected.real = 0.45309150865622423742786479802143446001648804616;
  expected.imaginary = -0.3197032151690024732069249793899422918384171475;
  assertEqual(res, expected, 1.0e-7);

  res = divide(a.real, b);
  expected.real = 0.08969497114591920857378400659521846661170651277;
  expected.imaginary = -0.4009892827699917559769167353668590272052761747;
  assertEqual(res, expected, 1.0e-7);

  float absRes = abs(a);
  float absExpected = 4.31856457633783681736543127297124342394929;
  assert(abs(absRes-absExpected) < 1.0e-6);

  res = sqrt(a);
  expected.real = 1.9388868683264937747198454519510440355532917532;
  expected.imaginary = 0.747851782219524037073515212692618569187849779814;
  assertEqual(res, expected, 1.0e-6);

  /* res = complex polar(float r, float theta); */
  /* expected.real = 1.9388868683264937747198454519510440355532917532; */
  /* expected.imaginary = 0.747851782219524037073515212692618569187849779814; */
  /* assertEqual(res, expected, 1.0e-6); */
}

void testPolyGen()
{
  testComplexMath();
  uniform vec3f ray_origin = make_vec3f(-4.0, 2.0, 1.0);
  uniform vec3f ray_dir = normalize(make_vec3f(0.3, 0.6, 0.2) - ray_origin);
  uniform vec3f glyph_center = make_vec3f(0.4, 0.3, -0.1);

  uniform float sh_coeffs[] = {1.74, -0.72, 0.62, 2.77, -1.65, -0.53, -0.58, 1.09, 0.28, -0.36, 0.46, 0.28, -0.06, 0.80, 1.34};

  struct ortho_frame frame = get_orthonormal_frame(glyph_center, ray_origin, ray_dir);
  assert(abs(frame.frame_to_ray_space.vx.x-1) < 1e-2);
  assert(abs(frame.frame_to_ray_space.vx.y-0) < 1e-2);
  assert(abs(frame.frame_to_ray_space.vy.x-13.21034026) < 1e-2);
  assert(abs(frame.frame_to_ray_space.vy.y-2.73521048) < 1e-2);

  float sh_poly[5];
  get_planar_sh_polynomial_4(sh_coeffs, ray_dir, frame.closest_dir, sh_poly);
  float poly[11];
  vec3f debug_col;
  get_poly(sh_coeffs, ray_dir, frame, poly, debug_col);

  uniform float poly_expected[] = {13.71435791, -63.44664606, -18.73962682, 266.07121489, -90.01305531, -242.44113876, 132.2596363, -8.33365172, -4.8709771, 0., -1.};
  for (int i = 0; i < 11; ++i)
    assert(abs(poly[i] - poly_expected[i]) < 0.01);

  complex a[11];
  for (int i = 0; i < 11; ++i) {
    a[i].real = poly[i];
    a[i].imaginary = 0;
  }
  complex x = {0,0};
  laguer(a, x, 11);
  assert(abs(x.real - 0.258963461279) < 1e-5);

  complex roots[11];
  zroots(poly, roots, true, debug_col);

  uniform float roots_expected[] = {-3.53524969, -0.838972339, -0.610389532, -0.185069938, -0.185069938, 0.258963461, 0.530182315, 0.862587817, 1.85150892, 1.85150892};
  for (int i = 0; i < 10; ++i)
    assert(abs(roots[i].real - roots_expected[i]) < 1.0e-5);

  float ray_roots[11];
  rootsToRaySpace(roots, ray_roots, frame);

  uniform float ray_roots_expected[] = {3.53723804, 4.52300399, 4.60657445, 4.76207239, 4.76207239, 4.92441215, 5.02357046, 5.14509877, 5.50665087, 5.50665087};
  for (uniform int i = 0; i < 10; ++i)
    assert(abs(ray_roots[i] - ray_roots_expected[i]) < 1.0e-5);

  /* SHIntersections hitData; */
  /* hitData.numIntersections = 0; */
  /* filterRealRoots(roots, ray_roots, &hitData); */

 /*  uniform float real_ray_roots_expected[] = {3.53723804, 4.52300399, 4.60657445, 4.92441215, 5.02357046, 5.14509877}; */
 /*  for (uniform int i = 0; i < 6; ++i) */
 /*    assert(abs(hitData.roots[i] - real_ray_roots_expected[i]) < 1.0e-5); */

 /* uniform float expected_normal_x[] = {-0.81824761, 0.84623132, 0.93375575, -0.77115485, -0.33109223, 0.13755328}; */
 /* uniform float expected_normal_y[] = {-0.50902668, 0.03363681, -0.15393211, -0.08527863, -0.34343862, -0.84198347}; */
 /* uniform float expected_normal_z[] = {-0.26713797, 0.53175287, 0.32311778, 0.63091026, 0.87887874, 0.52167321}; */
 /*  vec3f cRayOrg = ray_origin - glyph_center; */
 /*  for (uniform int i = 0; i < 6; ++i){ */
 /*    vec3f p = cRayOrg + hitData.roots[i] * ray_dir; */
 /*    vec3f n = get_sh_glyph_normal(sh_coeffs, p); */
 /*    assert(abs(expected_normal_x[i] - n.x) < 1.0e-5); */
 /*    assert(abs(expected_normal_y[i] - n.y) < 1.0e-5); */
 /*    assert(abs(expected_normal_z[i] - n.z) < 1.0e-5); */
 /*  } */
}
