// Copyright 2009-2021 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "rkcommon/math/vec.ih"
#include "math/AffineSpace.ih"

const uniform float EPSILON = 0.001;
const int STEPS_ = 700;

float sign(float v)
{
  return v < 0.f ? -1.f : 1.f;
}

#define k01 0.2820947918 // sqrt(  1/PI)/2
#define k02 0.4886025119 // sqrt(  3/PI)/2
#define k03 1.0925484306 // sqrt( 15/PI)/2
#define k04 0.3153915652 // sqrt(  5/PI)/4
#define k05 0.5462742153 // sqrt( 15/PI)/4
#define k06 0.5900435860 // sqrt( 70/PI)/8
#define k07 2.8906114210 // sqrt(105/PI)/2
#define k08 0.4570214810 // sqrt( 42/PI)/8
#define k09 0.3731763300 // sqrt(  7/PI)/4
#define k10 1.4453057110 // sqrt(105/PI)/4
#define k11 2.5033429418 // sqrt(35/PI)*3/4
#define k12 1.7701307698 // sqrt(70/PI)*3/8
#define k13 0.9461746958 // sqrt(5/PI)*3/4
#define k14 0.6690465436 // sqrt(10/PI)*3/8
#define k15 0.1057855469 // sqrt(1/PI)*3/16
#define k16 0.4730873479 // sqrt(5/PI)*3/8
#define k17 0.6258357355 // sqrt(35/PI)*3/16

#define sqrt2 sqrt(2.f);
#define four_pi_inv sqrt(four_pi);

float genSH(int l, int m, vec3f) {
  float condonShortley = (m % 2) ? -1.f : 1.f;
  float val = condonShortley * sqrt2;
  float inner = (2.f * l +1.f) * four_pi_inv;
}

#define INV_PI 1.0f/PI;

float shFunctions(vec3f n, uniform float* c) {

  const float r = length(n);
  n = n/r; // normalize
  /* n = make_vec3f(n.z, n.x, n.y); */

  const float x =n.x;
  const float y = n.y;
  const float z = n.z;
  const float x2 = x*x;
  const float y2 = y*y;
  const float z2 = z*z;
  const float xy = x*y;
  const float yz = y*z;
  const float xz = x*z;
  const float v5z2 = 5.f*z2;
  const float v7z2 = 7.f*z2;
  const float v3x2 = 3.f*x2;
  const float v3y2 = 3.f*y2;
  const float v7z2min1 = v7z2-1.f;
  const float v7z2min3 = v7z2-3.f;
  const float v5z2min1 = v5z2-1.f;
  const float x2miny2 = x2-y2;
  const float x2min3y2 = x2-v3y2;

  #if 1 // hyper optimize
  float v =
   (c[0]*k01) // l=0, m=0
  //----------------------------------------------------------
	-k02*(c[1]*y-c[2]*z+c[3]*x)
  //----------------------------------------------------------
  +k03*(c[4]*xy-c[5]*yz-c[7]*xz+c[8]*0.5f*x2miny2)
  +c[6]*(k04*(3.f*z2-1.f)) // l=2, m= 0
  //----------------------------------------------------------
  -k06*(c[9]*y*(v3x2-y2)+c[16]*x*(x2-v3y2))
  +k07*z*(c[10]*xy+c[14]*0.5f*(x2miny2))
  -k08*v5z2min1*(c[11]*y+c[13]*x)
  +c[12]*(k09*z*(v5z2-3.f)) // l=3, m= 0
  //----------------------------------------------------------
  /* +k11*(c[16]*xy*x2miny2-0.5*(c[17]*yz*(v3x2-y2)+c[23]*xz*x2min3y2)+0.25f*c[24]*(x2*x2min3y2-y2*(v3x2-y2))); */
  /* +k14*(-c[19]*y*v7z2min3-c[21]*x*v7z2min3) */
  +c[16]*(k11*xy*(x2miny2)) // l=4, m=-4
  -c[17]*(k12*yz*(v3x2-y2)) // l=4, m=-3
  +c[18]*(k13*xy*(v7z2min1)) // l=4, m=-2
  -c[19]*(k14*y*(v7z2min3)) // l=4, m=-1
  +c[20]*(k15*(35.f*z2*z2-30.f*z2+3.f)) // l=4, m= 0
  -c[21]*(k14*x*(v7z2min3)) // l=4, m= 1
  +c[22]*(k16*(x2miny2)*(v7z2min1)) // l=4, m= 2
  -c[23]*(k12*xz*(x2min3y2)) // l=4, m= 3
  +c[24]*(k17*x2*(x2min3y2)-y2*(v3x2-y2)); // l=4, m= 4
  return r-abs(v);
#else //legible
  return
   (c[0]*k01) // l=0, m=0
  //----------------------------------------------------------
	-c[1]*(k02*y) // l=1, m=-1
  +c[2]*(k02*z) // l=1, m= 0
  -c[3]*(k02*x) // l=1, m= 1
  //----------------------------------------------------------
	+c[4]*(k03*xy) // l=2, m=-2
  -c[5]*(k03*yz) // l=2, m=-1
  +c[6]*(k04*(3.f*z2-1.f)) // l=2, m= 0
  -c[7]*(k03*xz) // l=2, m= 1
  +c[8]*(k05*(x2miny2)) // l=2, m= 2
  //----------------------------------------------------------
  -c[9]*(k06*y*(v3x2-y2)) // l=3, m=-3
  +c[10]*(k07*xy*z) // l=3, m=-2
  -c[11]*(k08*y*(v5z2min1)) // l=3, m=-1
  +c[12]*(k09*z*(v5z2-3.f)) // l=3, m= 0
  -c[13]*(k08*x*(v5z2min1)) // l=3, m= 1
  +c[14]*(k10*z*(x2miny2)) // l=3, m= 2
  -c[15]*(k06*x*(x2-v3y2)) // l=3, m= 3
  //----------------------------------------------------------
  +c[16]*(k11*xy*(x2miny2)) // l=4, m=-4
  -c[17]*(k12*yz*(v3x2-y2)) // l=4, m=-3
  +c[18]*(k13*xy*(v7z2min1)) // l=4, m=-2
  -c[19]*(k14*y*(v7z2min3)) // l=4, m=-1
  +c[20]*(k15*(35.f*z2*z2-30.f*z2+3.f)) // l=4, m= 0
  -c[21]*(k14*x*(v7z2min3)) // l=4, m= 1
  +c[22]*(k16*(x2miny2)*(v7z2min1)) // l=4, m= 2
  -c[23]*(k12*xz*(x2min3y2)) // l=4, m= 3
  +c[24]*(k17*x2*(x2min3y2)-y2*(v3x2-y2)); // l=4, m= 4
  #endif

}

float SH(int l, int m, vec3f n) {
  if( l==0 )          return  k01;
  //----------------------------------------------------------
	if (l==1 && m==-1) return -k02*n.y;
  if (l==1 && m== 0) return  k02*n.z;
  if (l==1 && m== 1) return -k02*n.x;
  //----------------------------------------------------------
	if (l==2 && m==-2) return  k03*n.x*n.y;
  if (l==2 && m==-1) return -k03*n.y*n.z;
  if (l==2 && m== 0) return  k04*(3.f*n.z*n.z-1.f);
  if (l==2 && m== 1) return -k03*n.x*n.z;
  if (l==2 && m== 2) return  k05*(n.x*n.x-n.y*n.y);
  //----------------------------------------------------------
  if (l==3 && m==-3) return -k06*n.y*(3.f*n.x*n.x-n.y*n.y);
  if (l==3 && m==-2) return  k07*n.z*n.y*n.x;
  if (l==3 && m==-1) return -k08*n.y*(5.f*n.z*n.z-1.f);
  if (l==3 && m== 0) return  k09*n.z*(5.f*n.z*n.z-3.f);
  if (l==3 && m== 1) return -k08*n.x*(5.f*n.z*n.z-1.f);
  if (l==3 && m== 2) return  k10*n.z*(n.x*n.x-n.y*n.y);
  if (l==3 && m== 3) return -k06*n.x*(n.x*n.x-3.f*n.y*n.y);
  //----------------------------------------------------------
  if (l==4 && m==-4) return  k11*n.x*n.y*(n.x*n.x-n.y*n.y);
  if (l==4 && m==-3) return -k12*n.y*n.z*(3.f*n.x*n.x-n.y*n.y);
  if (l==4 && m==-2) return  k13*n.x*n.y*(7.f*n.z*n.z-1.f);
  if (l==4 && m==-1) return -k14*n.y*n.z*(7.f*n.z*n.z-3.f);
  if (l==4 && m== 0) return  k15*(35.f*n.z*n.z*n.z*n.z-30.f*n.z*n.z+3.f);
  if (l==4 && m== 1) return -k14*n.x*n.z*(7.f*n.z*n.z-3.f);
  if (l==4 && m== 2) return  k16*(n.x*n.x-n.y*n.y)*(7.f*n.z*n.z-1.f);
  if (l==4 && m== 3) return -k12*n.x*n.z*(n.x*n.x-3.f*n.y*n.y);
  if (l==4 && m== 4) return  k17*n.x*n.x*(n.x*n.x-3.f*n.y*n.y)-n.y*n.y*(3.f*n.x*n.x-n.y*n.y);
  //----------------------------------------------------------
  return 0.0;
}

vec3f SHGradient(varying vec3f p,
                 uniform float* coeffs)
{
  const float eps = 0.001;

  const vec3f epsX = make_vec3f(eps,0.f,0.f);
  const vec3f epsY = make_vec3f(0.f,eps,0.f);
  const vec3f epsZ = make_vec3f(0.f,0.f,eps);

  const float plusX = shFunctions(p + epsX, coeffs);
  const float minX = shFunctions(p - epsX, coeffs);
  const float plusY = shFunctions(p + epsY, coeffs);
  const float minY = shFunctions(p - epsY, coeffs);
  const float plusZ = shFunctions(p + epsZ, coeffs);
  const float minZ = shFunctions(p - epsZ, coeffs);

  return make_vec3f(plusX-minX, plusY-minY, plusZ-minZ);
}

struct complex {
float real;
float imaginary;
};

struct complex plus(struct complex& a, struct complex& b)
{
  complex c;
  c.real = a.real + b.real;
  c.imaginary = a.imaginary + b.imaginary;
  return c;
}

struct complex plus(struct complex& a, float b)
{
  complex c;
  c.real = a.real + b;
  return c;
}

struct complex minus(struct complex& a, struct complex& b)
{
  complex c;
  c.real = a.real - b.real;
  c.imaginary = a.imaginary - b.imaginary;
  return c;
}

struct complex minus(struct complex& a, float b)
{
  complex c;
  c.real = a.real - b;
  return c;
}

struct complex times(struct complex& a, struct complex& b)
{
  complex c;
  c.real = a.real * b.real - a.imaginary * b.imaginary;
  c.imaginary = a.real * b.imaginary + a.imaginary * b.real;
  return c;
}

struct complex times(struct complex& a, float b)
{
  complex c;
  c.real = a.real * b;
  c.imaginary = a.imaginary * b;
  return c;
}

struct complex conj(const struct complex& a)
{
  complex b;
  b.real = a.real;
  b.imaginary = -a.imaginary;
  return b;
}

struct complex divide(struct complex& a, struct complex& b)
{
  struct complex ret;
  float denom = (b.real*b.real+b.imaginary*b.imaginary);
  ret.real = (a.real*b.real + a.imaginary*b.imaginary) / denom;
  ret.imaginary = (a.imaginary*b.real - a.real*b.imaginary) / denom;
  return ret;
}

struct complex divide(float a, struct complex& b)
{
  struct complex ret;
  float denom = (b.real*b.real+b.imaginary*b.imaginary);
  ret.real = (a*b.real + b.imaginary) / denom;
  ret.imaginary = (b.real - a*b.imaginary) / denom;
  return ret;
}

float abs(struct complex& a)
{
  return sqrt(a.real*a.real+a.imaginary*a.imaginary);
}

struct complex sqrt(struct complex& a)
{
  float z = abs(a);
  complex c;
  c.real = sqrt(0.5f*(z+a.real));
  c.imaginary = sqrt(0.5f*(z-a.real));
  return c;
}

inline struct complex polar(float r, float theta) {
  struct complex ret = {r * cos(theta), r * sin(theta)};
  return ret;
}
inline struct complex laguer(const uniform float* a, float x0, int its)
{
  const static int MR = 8;
  const static int MT = 10;
  const static int MAXIT = MR*MT;
  const static float EPS = 1.0e-16;
  const float frac[9] = {0.0, 0.5, 0.25, 0.75, 0.13, 0.38, 0.62, 0.88, 1.0};

  struct complex dx, x, x1, b, d, f, g, h, sq, gp, gm, g2 = {0.f, 0.f};
  x.real = x.imaginary = 0.f;
  const int m = 14; // number of coefficients minus 1

  for (int iter = 1; iter < MAXIT; iter++) {
    its = iter;
    b.real = a[m];
    float err = abs(b);
    float abx = abs(x);
    for(int j=m-1; j>=0; j--) {
      f = plus(times(x,f), d);
      d = plus(times(x,d), b);
      b = plus(times(x,b), a[j]);
      err = abs(b) + abx*err;
    }
    err *= EPS;

    if (abs(b) <= err) return x; // TODO how to compare complex and real?
    g = divide(d,b);
    g2 = times(g,g);
    h = minus(g2, times(divide(f,b), 2.f));
    sq = sqrt(times(minus(times(h, (float)m), g2), (float)(m-1)));
    gp = plus(g, sq);
    gm = minus(g, sq);
    float abp = abs(gp);
    float abm = abs(gm);
    if (abp < abm) gp=gm;
    dx = max(abp, abm) > 0.f ? divide(m, gp) : polar(1.f+abx, (float)iter);
    x1 = minus(x, dx);
    if (x.real == x1.real) return x; // TODO is it fine to only check real?
    if (iter % MT != 0) x = x1;
    else x = minus(x, times(dx, frac[iter/MT]));
  }
  return x;
}

struct ortho_frame {
  linear2f frame_to_ray_space;
  vec3f closest_dir;
  float closest_dist;
};

ortho_frame get_orthonormal_frame(vec3f glyph_center, vec3f ray_origin, vec3f ray_dir)
{
    /*
    Produces an orthonormal coordinate frame for the plane that contains the
    given two points and the ray direction. All inputs are arrays of shape
    (3, ...).
    :param glyph_center: The center position of the SH glyph.
    :param ray_origin: The origin of the ray being traced.
    :param ray_dir: The normalized ray direction vector.
    :return: A tuple (frame_to_ray_space, ray_dir, closest_dir, closest_dist).
        ray_dir is simply passed through. closest_dir is an array of shape
        (3, ...) providing the normalized direction from glyph_center to the
        closest point on the ray and closest_dist (shape (...)) provides the
        corresponding distance. Together the two vectors form an orthonormal
        frame. frame_to_ray_space is a matrix of shape (2, 2, ...). It converts
        from a coordinate frame where the x-axis corresponds to ray_dir and the
        y-axis corresponds to closest_dir to a coordinate frame where the x-axis
        corresponds to ray_dir and the y-axis corresponds to
        ray_origin - glyph_center.
    */
    struct ortho_frame frame;
    vec3f offset = ray_origin - glyph_center;
    float ray_dot_offset = dot(ray_dir, offset);
    frame.closest_dir = offset - ray_dot_offset * ray_dir;
    frame.closest_dist = length(frame.closest_dir);
    float inv_closest_dist = 1.0 / frame.closest_dist;
    frame.closest_dir = frame.closest_dir * inv_closest_dist;
    frame.frame_to_ray_space.vx = make_vec2f(1.0, -inv_closest_dist * ray_dot_offset);
    frame.frame_to_ray_space.vy = make_vec2f(0.0, inv_closest_dist);
    return frame;
}

void evaluate_sh_4(float point[3][5], bool evaluate_gradient, bool evaluate_hessian, float sh[5][15]) {
    /*
    Evaluates spherical harmonics basis functions in bands 0, 2 and 4. For the
    most part, it follows the conventions of "Stupid Spherical Harmonics (SH)
    Tricks" by Peter-Pike Sloan 2008:
    https://www.ppsloan.org/publications/StupidSH36.pdf
    For normalized vectors, results are the same as with the formulas in this
    work. The major difference is that the polynomials have been made
    homogeneous of degree 4, i.e. scaling point by a factor r scales the SH
    basis functions by a factor of r^4 and their gradient by r^3.
    :param point: An array of shape (3, ...) providing the Cartesian coordinates
        at which the spherical harmonics basis functions should be evaluated.
    :param evaluate_gradient: Pass True to also evaluate the gradient of the SH
        basis functions.
    :param evaluate_hessian: Pass True to also evaluate the Hessian matrix of
        the SH basis functions. Implies evaluate_gradient.
    :return: The requested arrays from the set sh, gradient, hessian in this
        order. sh has shape (15, ...). gradient has shape (3, 15, ...), where
        the first dimension corresponds to the three dimensions along which the
        derivative can be taken. hessian has shape (6, 15, ...) where the first
        dimension corresponds to the entries [0, 0], [0, 1], [0, 2], [1, 1],
        [1, 2], [2, 2] of the symmetric matrix. The dimension of length 15 lists
        SH basis functions ordered by band. That means the index tuples
        (band, order) are as follows:
        [0] -> (0, 0)
        [1] -> (2, -2)
        [2] -> (2, -1)
        [3] -> (2, 0)
        [4] -> (2, 1)
        [5] -> (2, 2)
        [6] -> (4, -4)
        [7] -> (4, -3)
        [8] -> (4, -2)
        [9] -> (4, -1)
        [10] -> (4, 0)
        [11] -> (4, 1)
        [12] -> (4, 2)
        [13] -> (4, 3)
        [14] -> (4, 4)
    */
    // This initial part is rather NumPy specific but everything else should be
    // easy to port to other languages
    /* int shape = sizeof(point)/sizeof(point[0]) / 3; */
    #define shape 5 // TODO undo hardcode
    /* float sh[5 * 15]; */
    // For homogenization, we express the associated Legendre polynomials as
    // homogeneous polynomials of the variables z and r = sqrt(x^2 + y^2)
    /* #define x point[0] */
    /* float* x = &point[0]; */
    /* float* y = &point[1]; */
    /* float* z = &point[2]; */

    float z_2[shape];
    float r_2[shape];
    for (int i = 0; i < shape; ++i) {
      z_2[i] = point[2][i] * point[2][i];
      r_2[i] = point[0][i] * point[0][i] + point[1][i] * point[1][i];
    }
    // Evaluate the relevant associated Legendre polynomials. At such low degree,
    // the recurrent scheme is not worthwhile. We skip odd bands and constant or
    // linear polynomials.
    float legendre_4_0[shape];
    float scaled_legendre_4_1[shape];
    float scaled_legendre_4_2[shape];
    float cosine_2[shape];
    float sine_2[shape];
    float cosine_3[shape];
    float sine_3[shape];
    float cosine_4[shape];
    float sine_4[shape];
    float one_2[shape];
    for (int i = 0; i < shape; ++i) {
      legendre_4_0[i] = z_2[i] * (z_2[i] - 3.0*r_2[i]) + 3.0/8.0 * r_2[i] * r_2[i];
      scaled_legendre_4_1[i] = 2.67618617422915667 * point[2][i] * (-z_2[i] + 0.75 * r_2[i]);
      scaled_legendre_4_2[i] = 2.83852408727268005 * (z_2[i] - (1.0 / 6.0) * r_2[i]);
      // Evaluate the Fourier basis. Again, we omit constant and linear terms.
      cosine_2[i] = r_2[i] - 2.0 * point[1][i] * point[1][i];
      sine_2[i] = 2.0 * point[0][i] * point[1][i];
      cosine_3[i] = point[0][i] * cosine_2[i] - point[1][i] * sine_2[i];
      sine_3[i] = point[0][i] * sine_2[i] + point[1][i] * cosine_2[i];
      cosine_4[i] = point[0][i] * cosine_3[i] - point[1][i] * sine_3[i];
      sine_4[i] = point[0][i] * sine_3[i] + point[1][i] * cosine_3[i];
      // Assemble the Legendre polynomials and the Fourier basis with appropriate
      // constant factors and homogenize to degree 4 by multiplying one_2 as needed
      one_2[i] = r_2[i] + z_2[i];
      sh[i][0] = 0.282094791773878143 * one_2[i] * one_2[i];
      sh[i][1] = 0.546274215296039535 * one_2[i] * sine_2[i];
      sh[i][2] = -1.09254843059207907 * one_2[i] * point[1][i] * point[2][i];
      sh[i][3] = 0.630783130505040012 * one_2[i] * (z_2[i] - 0.5 * r_2[i]);
      sh[i][4] = -1.09254843059207907 * one_2[i] * point[0][i] * point[2][i];
      sh[i][5] = 0.546274215296039535 * one_2[i] * cosine_2[i];
      sh[i][6] = 0.625835735449176135 * sine_4[i];
      sh[i][7] = -1.77013076977993053 * sine_3[i] * point[2][i];
      sh[i][8] = sine_2[i] * scaled_legendre_4_2[i];
      sh[i][9] = point[1][i] * scaled_legendre_4_1[i];
      sh[i][10] = 0.846284375321634430 * legendre_4_0[i];
      sh[i][11] = point[0][i] * scaled_legendre_4_1[i];
      sh[i][12] = cosine_2[i] * scaled_legendre_4_2[i];
      sh[i][13] = -1.77013076977993053 * cosine_3[i] * point[2][i];
      sh[i][14] = 0.625835735449176135 * cosine_4[i];
    }
    /* if (!evaluate_gradient && !evaluate_hessian) */
      /* return sh; */
}

void evaluate_sh_4(float point[3][5],  float sh[5][15]) { evaluate_sh_4(point, false, false, sh); }

float* get_planar_sh_polynomial_4(const uniform float* sh_coeffs, vec3f x_axis, vec3f y_axis, float sh_poly[5]) {
    /*
    Constructs a homogeneous quartic polynomial in the monic basis describing
    the behavior of a linear combination of SH basis functions in bands 0, 2, 4
    in a plane spanned by two given vectors.
    :param sh_coeffs: Spherical harmonics coefficients for bands 0, 2 and 4. See
        evaluate_sh_4() for their order. Array of shape (15, ...).
    :param x_axis: The x-axis of the coordinate frame. Array of shape (3, ...).
    :param y_axis: The y-axis of the coordinate frame. Array of shape (3, ...).
    :return: Polynomial coefficients for y^4, y^3*x, y^2*x^2, y*x^3, x^4 in this
        order. Array of shape (5, ...).
    */
    // Evaluate at fixed pairs of x and y. These points are rather arbitrary. The
    // main goals in choosing them are that the computation of polynomial
    // coefficients is fast and numerically stable. See invert_vandermonde().
    const uniform float xs[] = {-pow(0.5,0.25), pow(0.5,0.25), 2.0, 0.0, 1.0};
    const uniform float ys[] = { pow(0.5,0.25), pow(0.5,0.25), 1.0, 1.0, 0.0};
    float points[3][5];
    for (uniform int i = 0; i < 3; ++i)
      for (uniform int j = 0; j < 5; ++j)
        points[i][j] = xs[j] * get(x_axis, i) + ys[j] * get(y_axis, i);

    float shs[5][15];
    evaluate_sh_4(points, shs);
    float poly_values[5] = {0};
    for (uniform int i = 0; i < 5; ++i) {
      sh_poly[i] = 0;
    /* print("shs %d\n", shs[i][0]); */
      for (uniform int j = 0; j < 15; ++j)
        poly_values[i] += shs[i][j] * sh_coeffs[j];
    }

    // Construct the polynomial coefficients
    sh_poly[0] = poly_values[3];
    sh_poly[4] = poly_values[4];
    const uniform float inv_vander[3][5] = {{-2.0 / 3.0, 2.0, -1.0 / 6.0, -0.5, 2.0},
                                            {1.0, 1.0, 0.0, -1.0, -1.0},
                                            {-1.0 / 3.0, -1.0, 1.0 / 6.0, 0.5, -2.0}};
    for (uniform int i = 1; i < 4; ++i)
      for (uniform int j = 0; j < 5; ++j)
        sh_poly[i] += inv_vander[i-1][j] * poly_values[j];
}

/* void zroots(float* a, bool polish) { */
/*     float EPS = 1.0e-14; */
/*     int m = length(a)-1; */
/*     struct complex x, b, c = {0,0}; */
/*     // default root values need to avoid stopping criteria(imag == 0 in our case) */
/*     struct complex roots[m+1] {1e16, 1e16}; */
/*     /\* roots = np.full(m+1, complex(np.finfo(np.double).max,np.finfo(np.double).max), dtype=np.cdouble); *\/ */
/*     struct complex ad[length(a)]; */
/*     for (int i = 0; i < length(a); ++i) */
/*       ad[i] = a[i]; */
/*     /\* ad = np.copy(a); // copy of coefficients for successive deflation *\/ */
/*     /\* for j in range(m-1, -1, -1): // loop over each root to be found *\/ */
/*     for (int j = m-1; j > -1; --j) { // loop over each root to be found */
/*         float x = 0.0; // start at zero to favor convergence to smallest remaining root */
/*         float ad_v[j+2]; */
/*         for (int i = 0; i <j+2; ++i) */
/*           ad_v[i] = ad_[i]; */
/*         x, = laguer(ad_v, x); */
/*         if (abs(np.imag(x)) <= 2.0*EPS*abs(np.real(x))): */
/*             x = complex(np.real(x), 0.0); */
/*         roots[j] = x; */
/*         b = ad[j+1]; // forward deflation */
/*         for jj in range(j, -1, -1): */
/*             c = ad[jj]; */
/*             ad[jj] = b; */
/*             b = x*b+c; */

/*     // polish roots using undeflated coefficients */
/*     if (polish): */
/*         for j in range(m): */
/*             x, its = laguer(a, roots[j]); */
/*     // sort roots by real parts by straight insertion */
/*     for j in range(1, m, 1): */
/*         x = roots[j]; */
/*         i = j-1; */
/*         while (i >= 0): */
/*             if (np.real(roots[i]) <= np.real(x)): */
/*                 break; */
/*             roots[i+1] = roots[i]; */
/*             i -= 1; */
/*         roots[i+1] = x; */
/*     return roots; */
/* } */

float* get_poly(const uniform float* sh_coeffs, vec3f ray_dir, struct ortho_frame frame, float poly[11]) {
    float sh_poly[5];
    get_planar_sh_polynomial_4(sh_coeffs, ray_dir, frame.closest_dir, sh_poly);
    // Square this polynomial
    float sh_square[9] = {0};
    for (int i = 0; i < 9; ++i)
      for (int j = max(0, i-4); j < min(4,i)+1; ++j)
        sh_square[i] += sh_poly[j] * sh_poly[i - j];
    // Increase the degree of the polynomial from 8 to 10 assuming y=closest_dist
    //float* poly = new float[11];
    float inv_dist_sq = 1.0 / (frame.closest_dist * frame.closest_dist);
    for (uniform int i = 0; i < 9; ++i)
      poly[i] = inv_dist_sq * sh_square[i];
    poly[9] = poly[10] = 0;
    /* poly = np.concatenate([(1.0 / (frame->closest_dist * frame->closest_dist)) * sh_square, [0.0, 0.0]]) */
    // Subtract (x^2+y^2)^5 (which can be computed using the binomial theorem)
    poly[0] -= 1.0;
    poly[2] -= 5.0;
    poly[4] -= 10.0;
    poly[6] -= 10.0;
    poly[8] -= 5.0;
    poly[10] -= 1.0;
}

/* void get_sh_glyph_intersections(float** sh_coeffs, vec3f glyph_center, vec3f ray_origin, vec3f ray_dir) */
/* { */
/*     /\* */
/*     Computes all intersections between a ray and a glyph defined by a linear */
/*     combination of spherical harmonics basis functions. */
/*     :param sh_coeffs: Spherical harmonics coefficients for bands 0, 2 and 4. See */
/*         evaluate_sh_4() for their order. Shape 15. */
/*     :param glyph_center: The center position of the SH glyph. Shape 3. */
/*     :param ray_origin: The origin of the ray being traced. Shape 3. */
/*     :param ray_dir: The normalized ray direction vector. Shape 3. */
/*     :return: An array of shape 10 providing ray parameters at which */
/*         intersections exist. Some of them may be complex or negative. */
/*     *\/ */
/*     // Get a polynomial for the SH polynomial in the relevant plane */
/*     struct ortho_frame* frame = get_orthonormal_frame(glyph_center, ray_origin, ray_dir); */
/*     float* poly = get_poly(sh_coeffs, ray_dir, frame); */

/*     // Numpy does not have a handy function to compute roots for many polynomials */
/*     // in an array at once, hence I lost my motivation to vectorize things */
/*     float* roots = zroots(poly, True); */
/*     // Transform back to ray coordinates. We could have worked in global */
/*     // coordinates directly but this approach ought to be more stable. */
/*     float* ray_roots[length(roots)]; */
/*     for (int i = 0; i < length(roots); ++i) */
/*       ray_roots = frame->frame_to_ray_space * np.vstack([roots, np.ones_like(roots)]); */
/*     // Dehomogenize */
/*     return ray_roots[0] / ray_roots[1]; */
/* } */

float eval_poly(float poly[11], float t) {
  float y = 0.f;
  uniform int degree = 10; // TODO undo hardcode
  float t_pow = t;
  y += poly[0];
  for (uniform int i = 1; i < degree+1; ++i) {
    y += poly[i] * t_pow;
    t_pow *= t;
  }
  //y += poly[degree];
  return y;
}

inline Intersections intersectSphericalHarmonics(const vec3f& rayOrg,
    const vec3f& rayDir,
    const uniform vec3f& center,
    const uniform float* coeffs,
    const uniform int degreeL,
    const uniform float boundRadius)
{
  Intersections isect;
  isect.entry.hit = false;
  isect.exit.hit = false;
  isect.entry.t = inf;
  isect.exit.t = -inf;

  vec3f cRayOrg = rayOrg - center;

  // bounding sphere as starting point
  Intersections isectSphere = intersectSphere(cRayOrg, rayDir, make_vec3f(0.f, 0.f, 0.f), boundRadius);
  float dist = isectSphere.entry.t;
  float max_dist = isectSphere.exit.t;
  float step_size = boundRadius * 2.f / (float)STEPS_;

	vec3f res = make_vec3f(1e10,-1.0, 1.0);

  float h = 1.0;
  vec2f m = make_vec2f(-1.0);
  vec3f s;
  int stepTotal = 0;
  #if 1
  struct ortho_frame frame = get_orthonormal_frame(center, rayOrg, rayDir);
  float poly[11];
  get_poly(coeffs, rayDir, frame, poly);
  vec3f p = cRayOrg + dist * rayDir;
  float io = shFunctions(p, coeffs);
  bool movePos = io > 0;
  for(int step=0; step<STEPS_; step++) {
    if (abs(io) < EPSILON)
      break;
    p = cRayOrg + dist * rayDir;
    if ((movePos && io < 0) ||(!movePos && io > 0)) {
      step_size = -0.5 * step_size;
      movePos = !movePos;
    }
    /* print("%i,%i,%i,%i\n", coeffs[0], coeffs[1], coeffs[2], coeffs[3]); */
    vec2f r = frame.frame_to_ray_space * make_vec2f(dist,1);
    float t = r.x / r.y;
    io = eval_poly(poly, t);
    /* io = shFunctions(p, coeffs); */
    dist += step_size;
    }
  #elif 0
  vec3f p = cRayOrg + dist * rayDir;
  float io = shFunctions(p, coeffs);
  bool movePos = io > 0;
  for( int step=0; step<STEPS_; step++) {
    stepTotal = step;
    if (abs(io) < EPSILON)
      break;
    p = cRayOrg + dist * rayDir;
    if ((movePos && io < 0) ||(!movePos && io > 0)) {
      step_size = -0.5 * step_size;
      movePos = !movePos;
    }
    io = shFunctions(p, coeffs);

    dist += step_size;
  }
  #else
  vec3f p;
  vec3f gradient;
  float io = 100.f;
  float f = 100.f;
  isect.entry.u = 0.0;
  for(int step=0; step<STEPS_; step++) {
    if (step == STEPS_-1) return isect;
    if (dist > max_dist) return isect;
    if(abs(io) < EPSILON) break;
    p = cRayOrg + dist * rayDir;
    io = shFunctions(p, coeffs);
    dist += io*0.15;
    isect.entry.u = (float)step/(float)STEPS_;
    isect.entry.u = shFunctions(p, coeffs);
  }
  #endif
  isect.entry.hit = abs(io) < EPSILON;
  /* isect.entry.hit = true; */
  isect.entry.t = dist;
  isect.entry.N = normalize(SHGradient(p, coeffs));
  isect.entry.u = (float)stepTotal/(float)STEPS_;

  return isect;
}

void testPolyGen()
{
  uniform vec3f ray_origin = make_vec3f(-4.0, 2.0, 1.0);
  uniform vec3f ray_dir = normalize(make_vec3f(0.3, 0.6, 0.2) - ray_origin);
  uniform vec3f glyph_center = make_vec3f(0.4, 0.3, -0.1);

  uniform float sh_coeffs[] = {1.74, -0.72, 0.62, 2.77, -1.65, -0.53, -0.58, 1.09, 0.28, -0.36, 0.46, 0.28, -0.06, 0.80, 1.34};

  struct ortho_frame frame = get_orthonormal_frame(glyph_center, ray_origin, ray_dir);
  print("closest dir %d\n", frame.frame_to_ray_space.vy.x);

  float sh_poly[5];
  get_planar_sh_polynomial_4(sh_coeffs, ray_dir, frame.closest_dir, sh_poly);
  float poly[11];
  get_poly(sh_coeffs, ray_dir, frame, poly);
  for (uniform int i = 0; i < 5; ++i)
      print("%d",sh_poly[i]);
  print(",,,,");
  for (uniform int i = 0; i < 11; ++i)
      print("%d",poly[i]);
}
