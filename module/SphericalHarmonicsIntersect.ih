// Copyright 2009-2021 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "rkcommon/math/vec.ih"
#include "math/AffineSpace.ih"
#include "camera/PerspectiveCameraShared.h"
#include "sh.ih"
#include "bracketed_newton_bisection.ih"

#define NO_INTERSECTION 3.4e+38f

struct SHIntersections
{
  unsigned int numIntersections;
  float roots[10];
  vec3f normals[10];
};

// An orthogonal coordinate frame constructed from a view ray in relation to a
// glyph
struct orthogonal_frame_t {
	// The normalized ray direction
	vec3f ray_dir;
	// The normalized direction vector from the glyph center to the closest
	// point on the ray (or actually the infinite line)
	vec3f closest_dir;
	// The square of the minimal distance between the ray (or actually the
	// infinite line) and the glyph center
	float closest_dist_sq;
	// The dot product between ray_dir and the offset from the glyph center to
	// the ray origin
	float ray_dot_offset;
};


// Produces an orthonormal coordinate frame for the plane that contains the
// given two points and the ray direction.
// \param glyph_center The center position of the SH glyph.
// \param ray_origin The origin of the ray being traced.
// \param ray_dir The normalized ray direction vector.
orthogonal_frame_t get_orthonormal_frame(vec3f glyph_center, vec3f ray_origin, vec3f ray_dir) {
	orthogonal_frame_t result;
	vec3f offset = ray_origin - glyph_center;
	result.ray_dot_offset = dot(ray_dir, offset);
	result.closest_dir = offset - result.ray_dot_offset * ray_dir;
	result.closest_dist_sq = dot(result.closest_dir, result.closest_dir);
	result.closest_dir = result.closest_dir / sqrt(result.closest_dist_sq);
	result.ray_dir = ray_dir;
	return result;
}


// Constructs a homogeneous quartic polynomial describing the behavior of a
// linear combination of SH basis functions in bands 0, 2, 4 in a plane spanned
// by two given vectors.
// \param out_poly Polynomial coefficients for y^4, y^3*x, y^2*x^2, y*x^3 and
//		x^4 in this order.
// \param sh_coeffs Spherical harmonics coefficients for bands 0, 2 and 4. See
//		evaluate_sh_4() for their order.
// \param x_axis The x-axis of the coordinate frame.
// \param y_axis The y-axis of the coordinate frame.
void get_planar_sh_polynomial_4(float out_poly[5], const uniform float * uniform sh_coeffs, vec3f x_axis, vec3f y_axis) {
	// Evaluate at equidistant pairs of x and y on the unit circle. This choice
	// is rather arbitrary but is reasonable in terms of numerical accuracy and
	// gives correct results even without a homogenized SH basis.
	float poly_values[5];
	// [[unroll]]
	for (uniform int i = 0; i != 5; ++i) {
		float x = cos(i * 3.141592653589793f * 0.2f);
		float y = sin(i * 3.141592653589793f * 0.2f);
		vec3f point = x * x_axis + y * y_axis;
		float shs[15];
		evaluate_sh_4(shs, point);
		poly_values[i] = 0.0f;
		for (uniform int j = 0; j != 15; ++j)
			poly_values[i] += sh_coeffs[j] * shs[j];
	}
	// Construct the polynomial coefficients
	float inv_vander[5][5] = {
		{  0.2f, -0.247213595f,  0.647213595f,  0.647213595f, -0.247213595f },
		{  0.0f, -0.179611191f,  1.99191863f,  -1.99191863f,   0.179611191f },
		{ -2.0f,  2.34164079f,  -0.341640786f, -0.341640786f,  2.34164079f  },
		{  0.0f,  1.70130162f,  -1.05146222f,   1.05146222f,  -1.70130162f  },
		{  1.0f, 0.0f, 0.0f, 0.0f, 0.0f },
	};
	// [[unroll]]
	for (uniform int i = 0; i != 5; ++i) {
		out_poly[i] = 0.0f;
		// [[unroll]]
		for (uniform int j = 0; j != 5; ++j)
			out_poly[i] += inv_vander[i][j] * poly_values[j];
	}
}


// Compares the two entries of the given array with the given indices and
// swaps them in place if lhs is greater than rhs
void cmp(float a[10], uint lhs, uint rhs) {
	float a_lhs = a[lhs];
	a[lhs] = min(a[rhs], a_lhs);
	a[rhs] = max(a[rhs], a_lhs);
}


// Uses a sorting network to sort a list of floats in increasing order
void sort_10(float a[10]) {
	// This sorting network is taken from:
	// Donald E. Knuth, 1998, The Art of Computer Programming, Volume 3 -
	// Sorting and Searching, 2nd Edition
	cmp(a, 4, 9);  cmp(a, 3, 8);  cmp(a, 2, 7);  cmp(a, 1, 6);  cmp(a, 0, 5);  cmp(a, 1, 4);  cmp(a, 6, 9);  cmp(a, 0, 3);  cmp(a, 5, 8);  cmp(a, 0, 2);  cmp(a, 3, 6);  cmp(a, 7, 9);  cmp(a, 0, 1);  cmp(a, 2, 4);  cmp(a, 5, 7);  cmp(a, 8, 9);  cmp(a, 4, 6);  cmp(a, 1, 2);  cmp(a, 7, 8);  cmp(a, 3, 5);  cmp(a, 2, 5);  cmp(a, 6, 8);  cmp(a, 1, 3);  cmp(a, 4, 7);  cmp(a, 2, 3);  cmp(a, 6, 7);  cmp(a, 3, 4);  cmp(a, 5, 6);  cmp(a, 4, 5);
}


// Computes all intersections between a line segment and a glyph defined by a
// linear combination of spherical harmonics basis functions.
// \param sh_coeffs Spherical harmonics coefficients for bands 0, 2 and 4. See
// 	evaluate_sh_4() for their order.
// \param glyph_center The center position of the SH glyph.
// \param ray_origin The origin of the ray being traced.
// \param ray_dir The normalized ray direction vector.
// \param t_min The beginning of the interval of ray parameters in which
//		intersections should be searched.
// \param t_max The end of the interval of ray parameters.
// \return Up to 10 ray parameters at which intersections exist. They may be
//		negative. Sorted in ascending order. Ends with NO_INTERSECTION entries.
void get_sh_glyph_intersections_segment(float out_ray_roots[10], const uniform float * uniform sh_coeffs, const uniform vec3f& glyph_center, const vec3f& ray_origin, const vec3f& ray_dir, float t_min, float t_max) {
	// Get a polynomial for the SH polynomial in the relevant plane
	orthogonal_frame_t frame = get_orthonormal_frame(glyph_center, ray_origin, ray_dir);
	float sh_poly[5];
	get_planar_sh_polynomial_4(sh_poly, sh_coeffs, frame.ray_dir, frame.closest_dir);
	// Compute an upper bound for the absolute value of this polynomial on the
	// unit circle
	float sh_poly_bound = abs(sh_poly[0]) + abs(sh_poly[4]) + 0.325f * (abs(sh_poly[1]) + abs(sh_poly[3])) + 0.25f * abs(sh_poly[2]);
	// Square this polynomial and multiply by y^2 (i.e. append two zeros)
	float poly[11] = { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f };
	// [[unroll]]
	for (uniform int i = 0; i != 5; ++i)
		// [[unroll]]
		for (uniform int j = 0; j != 5; ++j)
			poly[i + j] += sh_poly[i] * sh_poly[j];
	// Subtract closest_dist_sq * (x^2+y^2)^5 (which can be computed using the
	// binomial theorem)
	poly[0] -= frame.closest_dist_sq;
	poly[2] -= 5.0f * frame.closest_dist_sq;
	poly[4] -= 10.0f * frame.closest_dist_sq;
	poly[6] -= 10.0f * frame.closest_dist_sq;
	poly[8] -= 5.0f * frame.closest_dist_sq;
	poly[10] -= frame.closest_dist_sq;
	// Compute bounds on where roots might be located
	float root_bound_sq = sh_poly_bound * (sh_poly_bound / frame.closest_dist_sq) - 1.0f;
	if (root_bound_sq < 0.0f) {
		// There are no intersections
		// [[unroll]]
		for (uniform int i = 0; i != 10; ++i)
			out_ray_roots[i] = NO_INTERSECTION;
		return;
	}
	float root_bound = sqrt(root_bound_sq);
	// Combine them with the given bounds
	float inv_closest_dist = 1.0 / sqrt(frame.closest_dist_sq);
	float x_min = (t_min + frame.ray_dot_offset) * inv_closest_dist;
	float x_max = (t_max + frame.ray_dot_offset) * inv_closest_dist;
	x_min = max(x_min, -root_bound);
	x_max = min(x_max, +root_bound);
	// Compute the roots in the local coordinate frame
	float roots[10];
	find_real_roots(roots, poly, x_min, x_max, 1.0e-3f * root_bound);
	// Transform back to ray coordinates. We could have worked in global
	// coordinates directly but this approach ought to be more stable.
	float closest_dist = 1.0f / inv_closest_dist;
	// [[unroll]]
	for (uniform int i = 0; i != 10; ++i)
		out_ray_roots[i] = isnan(roots[i]) ? NO_INTERSECTION : (roots[i] * closest_dist - frame.ray_dot_offset);
	// Sort the roots
	sort_10(out_ray_roots);
}


// Like get_sh_glyph_intersections_segment() but computes all intersections
// along the infinite line for the given ray.
void get_sh_glyph_intersections(float out_ray_roots[10], const uniform float * uniform sh_coeffs, const uniform vec3f& glyph_center, const vec3f& ray_origin, const vec3f& ray_dir) {
	get_sh_glyph_intersections_segment(out_ray_roots, sh_coeffs, glyph_center, ray_origin, ray_dir, -1.0e38f, 1.0e38f);
}


// Computes a unit normal vector for a spherical harmonics glyph.
// \param sh_coeffs Spherical harmonics coefficients for bands 0, 2 and 4. See
//		evaluate_sh_4() for their order.
// \param offset The position on the glyph at which the normal should be
//		evaluated, relative to the glyph center.
// \return The normalized normal vector.
vec3f get_sh_glyph_normal(const uniform float * uniform sh_coeffs, vec3f offset) {
	float shs[15];
	vec3f grads[15];
	evaluate_sh_4_grad(shs, grads, offset);
	float poly_value = 0.0f;
	vec3f poly_grad = make_vec3f(0.0f);
	// [[unroll]]
	for (uniform int i = 0; i != 15; ++i) {
		poly_value += sh_coeffs[i] * shs[i];
		poly_grad = poly_grad + sh_coeffs[i] * grads[i];
	}
	float length_2 = dot(offset, offset);
	vec3f normal = 5.0f * offset - (length_2 / poly_value) * poly_grad;
	return normalize(normal);
}

inline void intersectSphericalHarmonicsNewtonBisection(float out_ray_roots[10],
	const vec3f& rayOrg,
    const vec3f& rayDir,
    const uniform vec3f& center,
    const uniform float* uniform coeffs,
    varying SHIntersections* uniform hitData)
{
  get_sh_glyph_intersections(out_ray_roots, coeffs, center, rayOrg, rayDir);
}
